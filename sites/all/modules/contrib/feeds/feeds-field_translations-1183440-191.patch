diff --git a/feeds.info b/feeds.info
index 6e32601..eadb544 100644
--- a/feeds.info
+++ b/feeds.info
@@ -36,6 +36,7 @@ files[] = tests/feeds_mapper_date.test
 files[] = tests/feeds_mapper_date_multiple.test
 files[] = tests/feeds_mapper_field.test
 files[] = tests/feeds_mapper_file.test
+files[] = tests/feeds_mapper_multilingual_fields.test
 files[] = tests/feeds_mapper_path.test
 files[] = tests/feeds_mapper_profile.test
 files[] = tests/feeds_mapper_unique.test
diff --git a/feeds.info.orig b/feeds.info.orig
new file mode 100644
index 0000000..6e32601
--- /dev/null
+++ b/feeds.info.orig
@@ -0,0 +1,64 @@
+name = Feeds
+description = Aggregates RSS/Atom/RDF feeds, imports CSV files and more.
+package = Feeds
+core = 7.x
+dependencies[] = ctools
+dependencies[] = job_scheduler
+
+files[] = includes/FeedsConfigurable.inc
+files[] = includes/FeedsImporter.inc
+files[] = includes/FeedsSource.inc
+files[] = libraries/ParserCSV.inc
+files[] = libraries/http_request.inc
+files[] = libraries/PuSHSubscriber.inc
+
+; Plugins
+files[] = plugins/FeedsCSVParser.inc
+files[] = plugins/FeedsEntityProcessor.inc
+files[] = plugins/FeedsFetcher.inc
+files[] = plugins/FeedsFileFetcher.inc
+files[] = plugins/FeedsHTTPFetcher.inc
+files[] = plugins/FeedsNodeProcessor.inc
+files[] = plugins/FeedsOPMLParser.inc
+files[] = plugins/FeedsParser.inc
+files[] = plugins/FeedsPlugin.inc
+files[] = plugins/FeedsProcessor.inc
+files[] = plugins/FeedsSimplePieParser.inc
+files[] = plugins/FeedsSitemapParser.inc
+files[] = plugins/FeedsSyndicationParser.inc
+files[] = plugins/FeedsTermProcessor.inc
+files[] = plugins/FeedsUserProcessor.inc
+
+; Tests
+files[] = tests/feeds.test
+files[] = tests/feeds_date_time.test
+files[] = tests/feeds_mapper_date.test
+files[] = tests/feeds_mapper_date_multiple.test
+files[] = tests/feeds_mapper_field.test
+files[] = tests/feeds_mapper_file.test
+files[] = tests/feeds_mapper_path.test
+files[] = tests/feeds_mapper_profile.test
+files[] = tests/feeds_mapper_unique.test
+files[] = tests/feeds_mapper.test
+files[] = tests/feeds_mapper_config.test
+files[] = tests/feeds_fetcher_file.test
+files[] = tests/feeds_mapper_format_config.test
+files[] = tests/feeds_fetcher_http.test
+files[] = tests/feeds_processor_entity.test
+files[] = tests/feeds_processor_node.test
+files[] = tests/feeds_processor_term.test
+files[] = tests/feeds_processor_user.test
+files[] = tests/feeds_scheduler.test
+files[] = tests/feeds_mapper_link.test
+files[] = tests/feeds_mapper_summary.test
+files[] = tests/feeds_mapper_taxonomy.test
+files[] = tests/http_request.test
+files[] = tests/parser_csv.test
+
+; Views integration
+files[] = views/feeds_views_handler_argument_importer_id.inc
+files[] = views/feeds_views_handler_field_importer_name.inc
+files[] = views/feeds_views_handler_field_log_message.inc
+files[] = views/feeds_views_handler_field_severity.inc
+files[] = views/feeds_views_handler_field_source.inc
+files[] = views/feeds_views_handler_filter_severity.inc
diff --git a/feeds.module b/feeds.module
index 908b2f8..27aca43 100644
--- a/feeds.module
+++ b/feeds.module
@@ -969,6 +969,77 @@ function feeds_item_info_save($entity, $entity_id) {
 }
 
 /**
+ * Returns the language summary text for use in a mapper target summary_callback
+ *
+ * @param array $mapping
+ *   Associative array of the mapping settings.
+ * @param array $target
+ *   Array of target settings, as defined by the processor or
+ *   hook_feeds_processor_targets_alter().
+ * @param array $form
+ *   The whole mapping form.
+ * @param array $form_state
+ *   The form state of the mapping form.
+ *
+ * @return string
+ *   Returns, as a string that may contain HTML, the summary to display while
+ *   the full form isn't visible.
+ *   If the return value is empty, no summary and no option to view the form
+ *   will be displayed.
+ */
+function feeds_mapper_summary_language($mapping, $target, $form, $form_state) {
+  if (module_exists('locale')) {
+    list($field_name) = explode(':', $mapping['target']);
+    $info = field_info_field($field_name);
+    if ($info['translatable']) {
+      $language_options = array(LANGUAGE_NONE => t('All languages')) + locale_language_list('name');
+      if (empty($mapping['language'])) {
+        return t('Language: <strong>@search</strong>', array('@search' => $language_options[LANGUAGE_NONE]));
+      }
+      return t('Language: <strong>@search</strong>', array('@search' => $language_options[$mapping['language']]));
+    }
+  }
+  return FALSE;
+}
+
+/**
+ * Returns the language form for use in a mapper target form_callback
+ *
+ * @param array $mapping
+ *   Associative array of the mapping settings.
+ * @param array $target
+ *   Array of target settings, as defined by the processor or
+ *   hook_feeds_processor_targets_alter().
+ * @param array $form
+ *   The whole mapping form.
+ * @param array $form_state
+ *   The form state of the mapping form.
+ *
+ * @return string
+ *   Returns, as a string that may contain HTML, the summary to display while
+ *   the full form isn't visible.
+ *   If the return value is empty, no summary and no option to view the form
+ *   will be displayed.
+ */
+function feeds_mapper_form_language($mapping, $target, $form, $form_state) {
+  $form = array();
+  if (module_exists('locale')) {
+    list($field_name) = explode(':', $mapping['target']);
+    $info = field_info_field($field_name);
+    if ($info['translatable']) {
+      $language_options = array(LANGUAGE_NONE => t('All languages')) + locale_language_list('name');
+      $form['language'] = array(
+        '#type' => 'select',
+        '#title' => t('Language'),
+        '#options' => $language_options,
+        '#default_value' => !empty($mapping['language']) ? $mapping['language'] : LANGUAGE_NONE,
+      );
+    }
+  }
+  return $form;
+}
+
+/**
  * @}
  */
 
diff --git a/feeds.module.orig b/feeds.module.orig
new file mode 100644
index 0000000..908b2f8
--- /dev/null
+++ b/feeds.module.orig
@@ -0,0 +1,1403 @@
+<?php
+
+/**
+ * @file
+ * Feeds - basic API functions and hook implementations.
+ */
+
+// Common request time, use as point of reference and to avoid calls to time().
+define('FEEDS_REQUEST_TIME', time());
+// Do not schedule a feed for refresh.
+define('FEEDS_SCHEDULE_NEVER', -1);
+// Never expire feed items.
+define('FEEDS_EXPIRE_NEVER', -1);
+// An object that is not persistent. Compare EXPORT_IN_DATABASE, EXPORT_IN_CODE.
+define('FEEDS_EXPORT_NONE', 0x0);
+// Status of batched operations.
+define('FEEDS_BATCH_COMPLETE', 1.0);
+define('FEEDS_BATCH_ACTIVE', 0.0);
+
+/**
+ * @defgroup hooks Hook and callback implementations
+ * @{
+ */
+
+/**
+ * Implements hook_hook_info().
+ */
+function feeds_hook_info() {
+  $hooks = array(
+    'feeds_plugins',
+    'feeds_after_parse',
+    'feeds_before_import',
+    'feeds_before_update',
+    'feeds_presave',
+    'feeds_after_save',
+    'feeds_after_import',
+    'feeds_after_clear',
+    'feeds_processor_targets_alter',
+    'feeds_parser_sources_alter',
+  );
+
+  return array_fill_keys($hooks, array('group' => 'feeds'));
+}
+
+/**
+ * Implements hook_cron().
+ */
+function feeds_cron() {
+  // Expire old log entries.
+  db_delete('feeds_log')
+    ->condition('request_time', REQUEST_TIME - 604800, '<')
+    ->execute();
+
+  // Find importers that need to be rescheduled.
+  if (!$importers = feeds_reschedule()) {
+    return;
+  }
+
+  // @todo Maybe we should queue this somehow as well. This could be potentially
+  // very long.
+  $sources = db_query("SELECT feed_nid, id FROM {feeds_source} WHERE id IN (:ids)", array(':ids' => $importers));
+
+  foreach ($sources as $source) {
+    feeds_source($source->id, $source->feed_nid)->schedule();
+  }
+
+  feeds_reschedule(FALSE);
+}
+
+/**
+ * Implements hook_cron_job_scheduler_info().
+ *
+ * Compare queue names with key names in feeds_cron_queue_info().
+ */
+function feeds_cron_job_scheduler_info() {
+  $info = array();
+  $info['feeds_source_import'] = array(
+    'queue name' => 'feeds_source_import',
+  );
+  $info['feeds_source_clear'] = array(
+    'queue name' => 'feeds_source_clear',
+  );
+  $info['feeds_source_expire'] = array(
+    'queue name' => 'feeds_source_expire',
+  );
+  $info['feeds_push_unsubscribe'] = array(
+    'queue name' => 'feeds_push_unsubscribe',
+  );
+  return $info;
+}
+
+/**
+ * Implements hook_cron_queue_info().
+ */
+function feeds_cron_queue_info() {
+  $queues = array();
+  $queues['feeds_source_import'] = array(
+    'worker callback' => 'feeds_source_import',
+    'time' => 60,
+  );
+  $queues['feeds_source_clear'] = array(
+    'worker callback' => 'feeds_source_clear',
+  );
+  $queues['feeds_source_expire'] = array(
+    'worker callback' => 'feeds_source_expire',
+  );
+  $queues['feeds_push_unsubscribe'] = array(
+    'worker callback' => 'feeds_push_unsubscribe',
+  );
+
+  return $queues;
+}
+
+/**
+ * Scheduler callback for importing from a source.
+ */
+function feeds_source_import(array $job) {
+  $source = _feeds_queue_worker_helper($job, 'import');
+  $source->scheduleImport();
+}
+
+/**
+ * Scheduler callback for deleting all items from a source.
+ */
+function feeds_source_clear(array $job) {
+  $source = _feeds_queue_worker_helper($job, 'clear');
+  $source->scheduleClear();
+}
+
+/**
+ * Scheduler callback for expiring content.
+ */
+function feeds_source_expire(array $job) {
+  $source = _feeds_queue_worker_helper($job, 'expire');
+  $source->scheduleExpire();
+}
+
+/**
+ * Executes a method on a feed source.
+ *
+ * @param array $job
+ *   The job being run.
+ * @param string $method
+ *   The method to execute.
+ */
+function _feeds_queue_worker_helper(array $job, $method) {
+  $source = feeds_source($job['type'], $job['id']);
+  try {
+    $source->existing()->$method();
+  }
+  catch (FeedsNotExistingException $e) {
+    // Do nothing.
+  }
+  catch (Exception $e) {
+    $source->log($method, $e->getMessage(), array(), WATCHDOG_ERROR);
+  }
+
+  return $source;
+}
+
+/**
+ * Scheduler callback for unsubscribing from PuSH hubs.
+ */
+function feeds_push_unsubscribe($job) {
+  $source = feeds_source($job['type'], $job['id']);
+  $fetcher = feeds_plugin('FeedsHTTPFetcher', $source->importer->id);
+  $fetcher->unsubscribe($source);
+}
+
+/**
+ * Batch API worker callback. Used by FeedsSource::startBatchAPIJob().
+ *
+ * @see FeedsSource::startBatchAPIJob().
+ *
+ * @todo Harmonize Job Scheduler API callbacks with Batch API callbacks?
+ *
+ * @param $method
+ *   Method to execute on importer; one of 'import' or 'clear'.
+ * @param $importer_id
+ *   Identifier of a FeedsImporter object.
+ * @param $feed_nid
+ *   If importer is attached to content type, feed node id identifying the
+ *   source to be imported.
+ * @param $context
+ *   Batch context.
+ */
+function feeds_batch($method, $importer_id, $feed_nid = 0, &$context) {
+  $context['finished'] = FEEDS_BATCH_COMPLETE;
+  try {
+    $context['finished'] = feeds_source($importer_id, $feed_nid)->$method();
+  }
+  catch (Exception $e) {
+    drupal_set_message($e->getMessage(), 'error');
+  }
+}
+
+/**
+ * Reschedule one or all importers.
+ *
+ * @param string $importer_id
+ *   If TRUE, all importers will be rescheduled, if FALSE, no importers will
+ *   be rescheduled, if an importer id, only importer of that id will be
+ *   rescheduled.
+ *
+ * @return array
+ *   An list of importers that need rescheduling.
+ */
+function feeds_reschedule($importer_id = NULL) {
+  $reschedule = variable_get('feeds_reschedule', FALSE);
+
+  if ($importer_id === TRUE || $importer_id === FALSE) {
+    $reschedule = $importer_id;
+  }
+  elseif (is_string($importer_id) && $reschedule !== TRUE) {
+    $reschedule = array_filter((array) $reschedule);
+    $reschedule[$importer_id] = $importer_id;
+  }
+
+  if (isset($importer_id)) {
+    variable_set('feeds_reschedule', $reschedule);
+  }
+
+  if ($reschedule === TRUE) {
+    return feeds_enabled_importers();
+  }
+  elseif ($reschedule === FALSE) {
+    return array();
+  }
+
+  return $reschedule;
+}
+
+/**
+ * Implements feeds_permission().
+ */
+function feeds_permission() {
+  $perms = array(
+    'administer feeds' => array(
+      'title' => t('Administer Feeds'),
+      'description' => t('Create, update, delete importers, execute import and delete tasks on any importer.')
+    ),
+  );
+  foreach (feeds_importer_load_all() as $importer) {
+    $perms["import $importer->id feeds"] = array(
+      'title' => t('Import @name feeds', array('@name' => $importer->config['name'])),
+    );
+    $perms["clear $importer->id feeds"] = array(
+      'title' => t('Delete items from @name feeds', array('@name' => $importer->config['name'])),
+    );
+    $perms["unlock $importer->id feeds"] = array(
+      'title' => t('Unlock imports from @name feeds', array('@name' => $importer->config['name'])),
+      'description' => t('If a feed importation breaks for some reason, users with this permission can unlock them.')
+    );
+  }
+  return $perms;
+}
+
+/**
+ * Implements hook_forms().
+ *
+ * Declare form callbacks for all known classes derived from FeedsConfigurable.
+ */
+function feeds_forms() {
+  $forms = array();
+  $forms['FeedsImporter_feeds_form']['callback'] = 'feeds_form';
+  $plugins = FeedsPlugin::all();
+  foreach ($plugins as $plugin) {
+    $forms[$plugin['handler']['class'] . '_feeds_form']['callback'] = 'feeds_form';
+  }
+  return $forms;
+}
+
+/**
+ * Implements hook_menu().
+ */
+function feeds_menu() {
+  $items = array();
+  $items['import'] = array(
+    'title' => 'Import',
+    'page callback' => 'feeds_page',
+    'access callback' => 'feeds_page_access',
+    'file' => 'feeds.pages.inc',
+  );
+  $items['import/%feeds_importer'] = array(
+    'title callback' => 'feeds_importer_title',
+    'title arguments' => array(1),
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_import_form', 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('import', 1),
+    'file' => 'feeds.pages.inc',
+  );
+  $items['import/%feeds_importer/import'] = array(
+    'title' => 'Import',
+    'type' => MENU_DEFAULT_LOCAL_TASK,
+    'weight' => -10,
+  );
+  $items['import/%feeds_importer/delete-items'] = array(
+    'title' => 'Delete items',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_delete_tab_form', 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('clear', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_LOCAL_TASK,
+  );
+  $items['import/%feeds_importer/unlock'] = array(
+    'title' => 'Unlock',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_unlock_tab_form', 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('unlock', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_LOCAL_TASK,
+  );
+  $items['import/%feeds_importer/template'] = array(
+    'page callback' => 'feeds_importer_template',
+    'page arguments' => array(1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('import', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_CALLBACK,
+  );
+  $items['node/%node/import'] = array(
+    'title' => 'Import',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_import_tab_form', 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('import', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_LOCAL_TASK,
+    'weight' => 10,
+  );
+  $items['node/%node/delete-items'] = array(
+    'title' => 'Delete items',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_delete_tab_form', NULL, 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('clear', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_LOCAL_TASK,
+    'weight' => 11,
+  );
+  $items['node/%node/unlock'] = array(
+    'title' => 'Unlock',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('feeds_unlock_tab_form', NULL, 1),
+    'access callback' => 'feeds_access',
+    'access arguments' => array('unlock', 1),
+    'file' => 'feeds.pages.inc',
+    'type' => MENU_LOCAL_TASK,
+    'weight' => 11,
+  );
+  // @todo Eliminate this step and thus eliminate clearing menu cache when
+  // manipulating importers.
+  foreach (feeds_importer_load_all() as $importer) {
+    $items += $importer->fetcher->menuItem();
+  }
+  return $items;
+}
+
+/**
+ * Implements hook_admin_paths().
+ */
+function feeds_admin_paths() {
+  $paths = array(
+    'import' => TRUE,
+    'import/*' => TRUE,
+    'node/*/import' => TRUE,
+    'node/*/delete-items' => TRUE,
+    'node/*/log' => TRUE,
+  );
+  return $paths;
+}
+
+/**
+ * Menu loader callback.
+ */
+function feeds_importer_load($id) {
+  try {
+    return feeds_importer($id)->existing();
+  }
+  catch (FeedsNotExistingException $e) {}
+  catch (InvalidArgumentException $e) {}
+
+  return FALSE;
+}
+
+/**
+ * Title callback.
+ */
+function feeds_importer_title(FeedsImporter $importer) {
+  return $importer->config['name'];
+}
+
+/**
+ * Implements hook_theme().
+ */
+function feeds_theme() {
+  return array(
+    'feeds_upload' => array(
+      'file' => 'feeds.pages.inc',
+      'render element' => 'element',
+    ),
+    'feeds_source_status' => array(
+      'file' => 'feeds.pages.inc',
+      'variables' => array(
+        'progress_importing' => NULL,
+        'progress_clearing' => NULL,
+        'imported' => NULL,
+        'count' => NULL,
+      ),
+    ),
+  );
+}
+
+/**
+ * Menu access callback.
+ *
+ * @param $action
+ *   The action to be performed. Possible values are:
+ *   - import
+ *   - clear
+ *   - unlock
+ * @param $param
+ *   Node object or FeedsImporter id.
+ */
+function feeds_access($action, $param) {
+  if (!in_array($action, array('import', 'clear', 'unlock'))) {
+    // If $action is not one of the supported actions, we return access denied.
+    return FALSE;
+  }
+
+  $importer_id = FALSE;
+  if (is_string($param)) {
+    $importer_id = $param;
+  }
+  elseif ($param instanceof FeedsImporter) {
+    $importer_id = $param->id;
+  }
+  elseif ($param->type) {
+    $importer_id = feeds_get_importer_id($param->type);
+  }
+
+  // Check for permissions if feed id is present, otherwise return FALSE.
+  if ($importer_id) {
+    if (user_access('administer feeds') || user_access("{$action} {$importer_id} feeds")) {
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
+/**
+ * Access callback to determine if the user can import Feeds importers.
+ *
+ * Feeds imports require an additional access check because they are PHP
+ * code and PHP is more locked down than administer feeds.
+ */
+function feeds_importer_import_access() {
+  return user_access('administer feeds') && user_access('use PHP for settings');
+}
+
+/**
+ * Menu access callback.
+ */
+function feeds_page_access() {
+  if (user_access('administer feeds')) {
+    return TRUE;
+  }
+  foreach (feeds_enabled_importers() as $id) {
+    if (user_access("import $id feeds")) {
+      return TRUE;
+    }
+  }
+  return FALSE;
+}
+
+/**
+ * Implements hook_exit().
+ */
+function feeds_exit() {
+  // Process any pending PuSH subscriptions.
+  $jobs = feeds_get_subscription_jobs();
+  foreach ($jobs as $job) {
+    if (!isset($job['fetcher']) || !isset($job['source'])) {
+      continue;
+     }
+    $job['fetcher']->subscribe($job['source']);
+  }
+
+  if (drupal_static('feeds_log_error', FALSE)) {
+    watchdog('feeds', 'Feeds reported errors, visit the Feeds log for details.', array(), WATCHDOG_ERROR, 'admin/reports/dblog/feeds');
+  }
+}
+
+/**
+ * Implements hook_views_api().
+ */
+function feeds_views_api() {
+  return array(
+    'api' => 3,
+    'path' => drupal_get_path('module', 'feeds') . '/views',
+  );
+}
+
+/**
+ * Implements hook_ctools_plugin_api().
+ */
+function feeds_ctools_plugin_api($owner, $api) {
+  if ($owner == 'feeds' && $api == 'plugins') {
+    return array('version' => 1);
+  }
+}
+
+/**
+ * Implements hook_ctools_plugin_type().
+ */
+function feeds_ctools_plugin_type() {
+  return array(
+    'plugins' => array(
+      'cache' => TRUE,
+      'use hooks' => TRUE,
+      'classes' => array('handler'),
+    ),
+  );
+}
+
+/**
+ * Implements hook_feeds_plugins().
+ */
+function feeds_feeds_plugins() {
+  module_load_include('inc', 'feeds', 'feeds.plugins');
+  return _feeds_feeds_plugins();
+}
+
+/**
+ * Gets the feed_nid for a single entity.
+ *
+ * @param int $entity_id
+ *   The entity id.
+ * @param string $entity_type
+ *   The type of entity.
+ *
+ * @return int|bool
+ *   The feed_nid of the entity, or FALSE if the entity doesn't belong to a
+ *   feed.
+ */
+function feeds_get_feed_nid($entity_id, $entity_type) {
+  return db_query("SELECT feed_nid FROM {feeds_item} WHERE entity_type = :type AND entity_id = :id", array(':type' => $entity_type, ':id' => $entity_id))->fetchField();
+}
+
+/**
+ * Implements hook_entity_insert().
+ */
+function feeds_entity_insert($entity, $type) {
+  list($id) = entity_extract_ids($type, $entity);
+  feeds_item_info_insert($entity, $id);
+}
+
+/**
+ * Implements hook_entity_update().
+ */
+function feeds_entity_update($entity, $type) {
+  list($id) = entity_extract_ids($type, $entity);
+  feeds_item_info_save($entity, $id);
+}
+
+/**
+ * Implements hook_entity_delete().
+ */
+function feeds_entity_delete($entity, $type) {
+  list($id) = entity_extract_ids($type, $entity);
+
+  // Delete any imported items produced by the source.
+  db_delete('feeds_item')
+    ->condition('entity_type', $type)
+    ->condition('entity_id', $id)
+    ->execute();
+}
+
+/**
+ * Implements hook_node_validate().
+ */
+function feeds_node_validate($node, $form, &$form_state) {
+  if (!$importer_id = feeds_get_importer_id($node->type)) {
+    return;
+  }
+  // Keep a copy of the title for subsequent node creation stages.
+  // @todo: revisit whether $node still looses all of its properties
+  // between validate and insert stage.
+  $last_title = &drupal_static('feeds_node_last_title');
+  $last_feeds = &drupal_static('feeds_node_last_feeds');
+
+  // On validation stage we are working with a FeedsSource object that is
+  // not tied to a nid - when creating a new node there is no
+  // $node->nid at this stage.
+  $source = feeds_source($importer_id);
+
+  // Node module magically moved $form['feeds'] to $node->feeds :P.
+  // configFormValidate may modify $last_feed, smuggle it to update/insert stage
+  // through a static variable.
+  $last_feeds = $node->feeds;
+  $source->configFormValidate($last_feeds);
+
+  // If node title is empty, try to retrieve title from feed.
+  if (trim($node->title) == '') {
+    try {
+      $source->addConfig($last_feeds);
+      if (!$last_title = $source->preview()->title) {
+        throw new Exception();
+      }
+    }
+    catch (Exception $e) {
+      drupal_set_message($e->getMessage(), 'error');
+      form_set_error('title', t('Could not retrieve title from feed.'));
+    }
+  }
+}
+
+/**
+ * Implements hook_node_presave().
+ */
+function feeds_node_presave($node) {
+  // Populate $node->title and $node->feed from result of validation phase.
+  $last_title = &drupal_static('feeds_node_last_title');
+  $last_feeds = &drupal_static('feeds_node_last_feeds');
+  if (empty($node->title) && !empty($last_title)) {
+    $node->title = $last_title;
+  }
+  if (!empty($last_feeds)) {
+    $node->feeds = $last_feeds;
+  }
+  $last_title = NULL;
+  $last_feeds = NULL;
+}
+
+/**
+ * Implements hook_node_insert().
+ */
+function feeds_node_insert($node) {
+  // Source attached to node.
+  feeds_node_update($node);
+  if (isset($node->feeds) && $importer_id = feeds_get_importer_id($node->type)) {
+    $source = feeds_source($importer_id, $node->nid);
+    // Start import if requested.
+    if (feeds_importer($importer_id)->config['import_on_create'] && !isset($node->feeds['suppress_import'])) {
+      $source->startImport();
+    }
+    // Schedule the source.
+    $source->schedule();
+  }
+}
+
+/**
+ * Implements hook_node_update().
+ */
+function feeds_node_update($node) {
+  // Source attached to node.
+  if (isset($node->feeds) && $importer_id = feeds_get_importer_id($node->type)) {
+    $source = feeds_source($importer_id, $node->nid);
+    $source->addConfig($node->feeds);
+    $source->save();
+  }
+}
+
+/**
+ * Implements hook_node_delete().
+ */
+function feeds_node_delete($node) {
+  // Source attached to node.
+  // Make sure we don't leave any orphans behind: Do not use
+  // feeds_get_importer_id() to determine importer id as the importer may have
+  // been deleted.
+  if ($importer_id = db_query("SELECT id FROM {feeds_source} WHERE feed_nid = :nid", array(':nid' => $node->nid))->fetchField()) {
+    feeds_source($importer_id, $node->nid)->delete();
+  }
+}
+
+/**
+ * Implements hook_form_BASE_FORM_ID_alter().
+ */
+function feeds_form_node_form_alter(&$form, $form_state) {
+  if ($importer_id = feeds_get_importer_id($form['#node']->type)) {
+    // Set title to not required, try to retrieve it from feed.
+    if (isset($form['title'])) {
+      $form['title']['#required'] = FALSE;
+    }
+
+    // Enable uploads.
+    $form['#attributes']['enctype'] = 'multipart/form-data';
+
+    // Build form.
+    $source = feeds_source($importer_id, empty($form['#node']->nid) ? 0 : $form['#node']->nid);
+    $form['feeds'] = array(
+      '#type' => 'fieldset',
+      '#title' => t('Feed'),
+      '#tree' => TRUE,
+      '#weight' => 0,
+    );
+    $form['feeds'] += $source->configForm($form_state);
+    $form['#feed_id'] = $importer_id;
+  }
+}
+
+/**
+ * Implements hook_field_extra_fields().
+ */
+function feeds_field_extra_fields() {
+  $extras = array();
+  foreach (node_type_get_names() as $type => $name) {
+    if (feeds_get_importer_id($type)) {
+      $extras['node'][$type]['form']['feeds'] = array(
+        'label' => t('Feed'),
+        'description' => t('Feeds module form elements'),
+        'weight' => 0,
+      );
+    }
+  }
+  return $extras;
+}
+
+/**
+ * Implements hook_features_pipe_COMPONENT_alter() for component "feeds_importer".
+ *
+ * Automatically adds dependencies when a Feed importer is selected in Features.
+ */
+function feeds_features_pipe_feeds_importer_alter(&$pipe, $data, &$export) {
+  foreach ($data as $importer_id) {
+    if ($importer = feeds_importer_load($importer_id)) {
+      $export['dependencies'] = array_merge($export['dependencies'], $importer->dependencies());
+    }
+  }
+}
+
+/**
+ * Implements hook_system_info_alter().
+ *
+ * Goes through a list of all modules that provide Feeds plugins and makes them
+ * required if there are any importers using those plugins.
+ */
+function feeds_system_info_alter(array &$info, $file, $type) {
+  if ($type !== 'module' || !module_hook($file->name, 'feeds_plugins')) {
+    return;
+  }
+
+  // Don't make Feeds require itself, otherwise you can't disable Feeds until
+  // all importers are deleted.
+  if ($file->name === 'feeds' || !function_exists('ctools_include')) {
+    return;
+  }
+
+  // Get the plugins that belong to the current module.
+  ctools_include('plugins');
+  $module_plugins = array();
+  foreach (ctools_get_plugins('feeds', 'plugins') as $plugin_id => $plugin) {
+    if ($file->name === $plugin['module']) {
+      $module_plugins[$plugin_id] = TRUE;
+    }
+  }
+
+  // Check if any importers are using any plugins from the current module.
+  foreach (feeds_importer_load_all(TRUE) as $importer) {
+    $configuration = $importer->getConfig();
+
+    foreach (array('fetcher', 'parser', 'processor') as $plugin_type) {
+      $plugin_key = $configuration[$plugin_type]['plugin_key'];
+      if (isset($module_plugins[$plugin_key])) {
+        $info['required'] = TRUE;
+        break 2;
+      }
+    }
+  }
+
+  if (empty($info['required'])) {
+    return;
+  }
+
+  if (module_exists('feeds_ui') && user_access('administer feeds')) {
+    $info['explanation'] = t('Feeds is currently using this module for one or more <a href="@link">importers</a>.', array('@link' => url('admin/structure/feeds')));
+  }
+  else {
+    $info['explanation'] = t('Feeds is currently using this module for one or more importers.');
+  }
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup utility Utility functions
+ * @{
+ */
+
+/**
+ * Loads all importers.
+ *
+ * @param $load_disabled
+ *   Pass TRUE to load all importers, enabled or disabled, pass FALSE to only
+ *   retrieve enabled importers.
+ *
+ * @return
+ *   An array of all feed configurations available.
+ */
+function feeds_importer_load_all($load_disabled = FALSE) {
+  $feeds = array();
+  // This function can get called very early in install process through
+  // menu_router_rebuild(). Do not try to include CTools if not available.
+  if (function_exists('ctools_include')) {
+    ctools_include('export');
+    $configs = ctools_export_load_object('feeds_importer', 'all');
+    foreach ($configs as $config) {
+      if (!empty($config->id) && ($load_disabled || empty($config->disabled))) {
+        $feeds[$config->id] = feeds_importer($config->id);
+      }
+    }
+  }
+  return $feeds;
+}
+
+/**
+ * Gets an array of enabled importer ids.
+ *
+ * @return
+ *   An array where the values contain ids of enabled importers.
+ */
+function feeds_enabled_importers() {
+  return array_keys(_feeds_importer_digest());
+}
+
+/**
+ * Gets an enabled importer configuration by content type.
+ *
+ * @param $content_type
+ *   A node type string.
+ *
+ * @return
+ *   A FeedsImporter id if there is an importer for the given content type,
+ *   FALSE otherwise.
+ */
+function feeds_get_importer_id($content_type) {
+  $importers = array_flip(_feeds_importer_digest());
+  return isset($importers[$content_type]) ? $importers[$content_type] : FALSE;
+}
+
+/**
+ * Helper function for feeds_get_importer_id() and feeds_enabled_importers().
+ */
+function _feeds_importer_digest() {
+  $importers = &drupal_static(__FUNCTION__);
+  if ($importers === NULL) {
+    if ($cache = cache_get(__FUNCTION__)) {
+      $importers = $cache->data;
+    }
+    else {
+      $importers = array();
+      foreach (feeds_importer_load_all() as $importer) {
+        $importers[$importer->id] = isset($importer->config['content_type']) ? $importer->config['content_type'] : '';
+      }
+      cache_set(__FUNCTION__, $importers);
+    }
+  }
+  return $importers;
+}
+
+/**
+ * Resets importer caches. Call when enabling/disabling importers.
+ */
+function feeds_cache_clear($rebuild_menu = TRUE) {
+  cache_clear_all('_feeds_importer_digest', 'cache');
+  drupal_static_reset('_feeds_importer_digest');
+  cache_clear_all('plugins:feeds:plugins', 'cache');
+  ctools_include('export');
+  ctools_export_load_object_reset('feeds_importer');
+  drupal_static_reset('_node_types_build');
+  if ($rebuild_menu) {
+    menu_rebuild();
+  }
+}
+
+/**
+ * Exports a FeedsImporter configuration to code.
+ */
+function feeds_export($importer_id, $indent = '') {
+  ctools_include('export');
+  $result = ctools_export_load_object('feeds_importer', 'names', array('id' => $importer_id));
+  if (isset($result[$importer_id])) {
+    return ctools_export_object('feeds_importer', $result[$importer_id], $indent);
+  }
+}
+
+/**
+ * Logs to a file like /tmp/feeds_my_domain_org.log in temporary directory.
+ */
+function feeds_dbg($msg) {
+  if (variable_get('feeds_debug', FALSE)) {
+    if (!is_string($msg)) {
+      $msg = var_export($msg, TRUE);
+    }
+    $filename = trim(str_replace('/', '_', $_SERVER['HTTP_HOST'] . base_path()), '_');
+    $handle = fopen("temporary://feeds_$filename.log", 'a');
+    fwrite($handle, gmdate('c') . "\t$msg\n");
+    fclose($handle);
+  }
+}
+
+/**
+ * Writes to feeds log.
+ */
+function feeds_log($importer_id, $feed_nid, $type, $message, $variables = array(), $severity = WATCHDOG_NOTICE) {
+  if ($severity < WATCHDOG_NOTICE) {
+    $error = &drupal_static('feeds_log_error', FALSE);
+    $error = TRUE;
+  }
+  db_insert('feeds_log')
+    ->fields(array(
+      'id' => $importer_id,
+      'feed_nid' => $feed_nid,
+      'log_time' => time(),
+      'request_time' => REQUEST_TIME,
+      'type' => $type,
+      'message' => $message,
+      'variables' => serialize($variables),
+      'severity' => $severity,
+    ))
+    ->execute();
+}
+
+/**
+ * Loads an item info object.
+ *
+ * Example usage:
+ *
+ * $info = feeds_item_info_load('node', $node->nid);
+ */
+function feeds_item_info_load($entity_type, $entity_id) {
+  return db_select('feeds_item')
+    ->fields('feeds_item')
+    ->condition('entity_type', $entity_type)
+    ->condition('entity_id', $entity_id)
+    ->execute()
+    ->fetchObject();
+}
+
+/**
+ * Inserts an item info object into the feeds_item table.
+ */
+function feeds_item_info_insert($entity, $entity_id) {
+  if (isset($entity->feeds_item)) {
+    $entity->feeds_item->entity_id = $entity_id;
+    drupal_write_record('feeds_item', $entity->feeds_item);
+  }
+}
+
+/**
+ * Inserts or updates an item info object in the feeds_item table.
+ */
+function feeds_item_info_save($entity, $entity_id) {
+  if (isset($entity->feeds_item)) {
+    $entity->feeds_item->entity_id = $entity_id;
+    if (feeds_item_info_load($entity->feeds_item->entity_type, $entity_id)) {
+      drupal_write_record('feeds_item', $entity->feeds_item, array('entity_type', 'entity_id'));
+    }
+    else {
+      feeds_item_info_insert($entity, $entity_id);
+    }
+  }
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup instantiators Instantiators
+ * @{
+ */
+
+/**
+ * Gets an importer instance.
+ *
+ * @param $id
+ *   The unique id of the importer object.
+ *
+ * @return
+ *   A FeedsImporter object or an object of a class defined by the Drupal
+ *   variable 'feeds_importer_class'. There is only one importer object
+ *   per $id system-wide.
+ */
+function feeds_importer($id) {
+  return FeedsConfigurable::instance(variable_get('feeds_importer_class', 'FeedsImporter'), $id);
+}
+
+/**
+ * Gets an instance of a source object.
+ *
+ * @param $importer_id
+ *   A FeedsImporter id.
+ * @param $feed_nid
+ *   The node id of a feed node if the source is attached to a feed node.
+ *
+ * @return
+ *   A FeedsSource object or an object of a class defiend by the Drupal
+ *   variable 'source_class'.
+ */
+function feeds_source($importer_id, $feed_nid = 0) {
+  return FeedsSource::instance($importer_id, $feed_nid);
+}
+
+/**
+ * Gets an instance of a class for a given plugin and id.
+ *
+ * @param $plugin
+ *   A string that is the key of the plugin to load.
+ * @param $id
+ *   A string that is the id of the object.
+ *
+ * @return
+ *   A FeedsPlugin object.
+ *
+ * @throws Exception
+ *   If plugin can't be instantiated.
+ */
+function feeds_plugin($plugin, $id) {
+  ctools_include('plugins');
+  if ($class = ctools_plugin_load_class('feeds', 'plugins', $plugin, 'handler')) {
+    return FeedsConfigurable::instance($class, $id);
+  }
+  $args = array('%plugin' => $plugin, '@id' => $id);
+  if (user_access('administer feeds')) {
+    $args['@link'] = url('admin/structure/feeds/' . $id);
+    drupal_set_message(t('Missing Feeds plugin %plugin. See <a href="@link">@id</a>. Check whether all required libraries and modules are installed properly.', $args), 'warning', FALSE);
+  }
+  else {
+    drupal_set_message(t('Missing Feeds plugin %plugin. Please contact your site administrator.', $args), 'warning', FALSE);
+  }
+  $class = ctools_plugin_load_class('feeds', 'plugins', 'FeedsMissingPlugin', 'handler');
+  return FeedsConfigurable::instance($class, $id);
+}
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup include Funtions for loading libraries
+ * @{
+ */
+
+/**
+ * Includes a library file.
+ *
+ * @param $file
+ *   The filename to load from.
+ * @param $library
+ *   The name of the library. If libraries module is installed,
+ *   feeds_include_library() will look for libraries with this name managed by
+ *   libraries module.
+ */
+function feeds_include_library($file, $library) {
+  static $included = array();
+
+  if (!isset($included[$file])) {
+    $included[$file] = FALSE;
+
+    $library_dir = variable_get('feeds_library_dir', FALSE);
+    $feeds_library_path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds') . "/libraries/$file";
+
+    // Try first whether libraries module is present and load the file from
+    // there. If this fails, require the library from the local path.
+    if (module_exists('libraries') && file_exists(libraries_get_path($library) . "/$file")) {
+      require libraries_get_path($library) . "/$file";
+      $included[$file] = TRUE;
+    }
+    elseif ($library_dir && file_exists("$library_dir/$library/$file")) {
+      require "$library_dir/$library/$file";
+      $included[$file] = TRUE;
+    }
+    elseif (file_exists($feeds_library_path)) {
+      // @todo: Throws "Deprecated function: Assigning the return value of new
+      // by reference is deprecated."
+      require $feeds_library_path;
+      $included[$file] = TRUE;
+    }
+  }
+
+  return $included[$file];
+}
+
+/**
+ * Checks whether a library is present.
+ *
+ * @param $file
+ *   The filename to load from.
+ * @param $library
+ *   The name of the library. If libraries module is installed,
+ *   feeds_library_exists() will look for libraries with this name managed by
+ *   libraries module.
+ */
+function feeds_library_exists($file, $library) {
+
+  if (module_exists('libraries') && file_exists(libraries_get_path($library) . "/$file")) {
+    return TRUE;
+  }
+
+  elseif (file_exists(DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds') . "/libraries/$file")) {
+    return TRUE;
+  }
+
+  elseif ($library_dir = variable_get('feeds_library_dir', FALSE)) {
+    if (file_exists("$library_dir/$library/$file")) {
+      return TRUE;
+    }
+  }
+
+  return FALSE;
+}
+
+ /**
+ * Checks whether simplepie exists.
+ */
+function feeds_simplepie_exists() {
+  return (
+    feeds_library_exists('autoloader.php', 'simplepie') ||
+    feeds_library_exists('simplepie.compiled.php', 'simplepie') ||
+    feeds_library_exists('simplepie.mini.php', 'simplepie') ||
+    feeds_library_exists('simplepie.inc', 'simplepie')
+  );
+}
+
+/**
+ * Includes the simplepie library.
+ */
+function feeds_include_simplepie() {
+  $files = array(
+    'autoloader.php',
+    'simplepie.mini.php',
+    'simplepie.compiled.php',
+    'simplepie.inc',
+  );
+
+  foreach ($files as $file) {
+    if (feeds_include_library($file, 'simplepie')) {
+      return TRUE;
+    }
+  }
+
+  return FALSE;
+}
+
+/**
+ * @deprecated
+ *
+ * Simplified drupal_alter().
+ *
+ * - None of that 'multiple parameters by ref' crazyness.
+ * - Don't use module_implements() to allow hot including on behalf
+ *   implementations (see mappers/).
+ *
+ * @todo This needs to be removed and drupal_alter() used. This is crazy dumb.
+ */
+function feeds_alter($type, &$data) {
+  $args = array(&$data);
+  $additional_args = func_get_args();
+  array_shift($additional_args);
+  array_shift($additional_args);
+  $args = array_merge($args, $additional_args);
+
+  $hook = $type . '_alter';
+  foreach (module_list() as $module) {
+    if (module_hook($module, $hook)) {
+      call_user_func_array($module . '_' . $hook, $args);
+    }
+  }
+}
+
+/**
+ * @}
+ */
+
+/**
+ * Copy of valid_url() that supports the webcal scheme.
+ *
+ * @see valid_url().
+ *
+ * @todo Replace with valid_url() when http://drupal.org/node/295021 is fixed.
+ */
+function feeds_valid_url($url, $absolute = FALSE) {
+  if ($absolute) {
+    return (bool) preg_match("
+      /^                                                      # Start at the beginning of the text
+      (?:ftp|https?|feed|webcal):\/\/                         # Look for ftp, http, https, feed or webcal schemes
+      (?:                                                     # Userinfo (optional) which is typically
+        (?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*      # a username or a username and password
+        (?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@          # combination
+      )?
+      (?:
+        (?:[a-z0-9\-\.]|%[0-9a-f]{2})+                        # A domain name or a IPv4 address
+        |(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\])         # or a well formed IPv6 address
+      )
+      (?::[0-9]+)?                                            # Server port number (optional)
+      (?:[\/|\?]
+        (?:[|\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})   # The path and query (optional)
+      *)?
+    $/xi", $url);
+  }
+  else {
+    return (bool) preg_match("/^(?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})+$/i", $url);
+  }
+}
+
+/**
+ * Registers a feed subscription job for execution on feeds_exit().
+ *
+ * @param array $job
+ *   Information about a new job to queue; or if set to NULL (default), leaves
+ *   the current queued jobs unchanged.
+ *
+ * @return
+ *   An array of subscribe jobs to process.
+ *
+ * @see feeds_exit()
+ * @see feeds_get_subscription_jobs()
+ */
+function feeds_set_subscription_job(array $job = NULL) {
+  $jobs = &drupal_static(__FUNCTION__, array());
+  if (isset($job)) {
+    $jobs[] = $job;
+  }
+  return $jobs;
+}
+
+/**
+ * Returns the list of queued jobs to be run.
+ *
+ * @return
+ *   An array of subscribe jobs to process.
+ *
+ * @see feeds_set_subscription_job()
+ */
+function feeds_get_subscription_jobs() {
+  return feeds_set_subscription_job();
+}
+
+/**
+ * Implements hook_entity_property_info_alter().
+ */
+function feeds_entity_property_info_alter(&$info) {
+
+  foreach ($info as $entity_type => $entity_info) {
+    $info[$entity_type]['properties']['feed_nid'] = array(
+      'label' => 'Feed NID',
+      'type' => 'integer',
+      'description' => t('Nid of the Feed Node that imported this entity.'),
+      'getter callback' => 'feeds_get_feed_nid_entity_callback',
+    );
+  }
+}
+
+/**
+ * Gets the feed_nid for an entity for use in entity metadata.
+ */
+function feeds_get_feed_nid_entity_callback($entity, array $options, $name, $entity_type) {
+  list($entity_id, , ) = entity_extract_ids($entity_type, $entity);
+
+  $feed_nid = feeds_get_feed_nid($entity_id, $entity_type);
+
+  if ($feed_nid === FALSE) {
+    return NULL;
+  }
+  return $feed_nid;
+}
+
+/**
+ * Implements hook_file_download().
+ */
+function feeds_file_download($uri) {
+  $id = db_query("SELECT id FROM {feeds_source} WHERE source = :uri", array(':uri' => $uri))->fetchField();
+
+  if (!$id) {
+    // File is not associated with a feed.
+    return;
+  }
+
+   // Get the file record based on the URI. If not in the database just return.
+  $files = file_load_multiple(array(), array('uri' => $uri));
+  foreach ($files as $item) {
+    // Since some database servers sometimes use a case-insensitive comparison
+    // by default, double check that the filename is an exact match.
+    if ($item->uri === $uri) {
+      $file = $item;
+      break;
+    }
+  }
+  if (!isset($file)) {
+    return;
+  }
+
+  // Check if this file belongs to Feeds.
+  $usage_list = file_usage_list($file);
+  if (!isset($usage_list['feeds'])) {
+    return;
+  }
+
+  if (!feeds_access('import', $id)) {
+    // User does not have permission to import this feed.
+    return -1;
+  }
+
+  // Return file headers.
+  return file_get_content_headers($file);
+}
+
+/**
+ * Feeds API version.
+ */
+function feeds_api_version() {
+  $version = feeds_ctools_plugin_api('feeds', 'plugins');
+  return $version['version'];
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function node_form_feedsentityprocessor_feeds_form_alter(&$form, &$form_state) {
+  if ($form['#configurable']->entityType() == 'node') {
+    unset($form['values']['title']);
+    $form['values']['author']['#required'] = FALSE;
+    $form['values']['author']['#autocomplete_path'] = 'user/autocomplete';
+    array_unshift($form['#validate'], 'node_form_feedsentityprocessor_feeds_form_validate');
+    if (is_numeric($form['values']['author']['#default_value']) &&
+      $account = user_load($form['values']['author']['#default_value'])) {
+      $form['values']['author']['#default_value'] = $account->name;
+    }
+  }
+}
+
+/**
+ * Validation callback for node_form_feedsentityprocessor_feeds_form_alter().
+ */
+function node_form_feedsentityprocessor_feeds_form_validate(&$form, &$form_state) {
+  if (empty($form_state['values']['values']['author'])) {
+    form_set_value($form['values']['author'], 0, $form_state);
+  }
+  else {
+    $account = user_load_by_name($form_state['values']['values']['author']);
+    if ($account) {
+      form_set_value($form['values']['author'], $account->uid, $form_state);
+    }
+  }
+}
+
+/**
+ * Implements hook_feeds_processor_targets_alter().
+ */
+function node_feeds_processor_targets_alter(&$targets, $entity_type, $bundle) {
+  if ($entity_type == 'node') {
+    $targets['nid']['name'] = t('Node id');
+    $targets['nid']['description'] = t('The nid of the node. NOTE: use this feature with care, node ids are usually assigned by Drupal.');
+  }
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function user_form_feedsentityprocessor_feeds_form_alter(&$form, &$form_state) {
+  if ($form['#configurable']->entityType() == 'user') {
+    unset($form['values']['name']);
+    $form['values']['mail']['#required'] = FALSE;
+  }
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function taxonomy_form_feedsentityprocessor_feeds_form_alter(&$form, &$form_state) {
+  if ($form['#configurable']->entityType() == 'taxonomy_term') {
+    unset($form['values']['name']);
+    if (empty($form['values']['weight']['#default_value'])) {
+      $form['values']['weight']['#default_value']= '';
+    }
+    array_unshift($form['#validate'], 'taxonomy_form_feedsentityprocessor_feeds_form_validate');
+    unset($form['values']['parent']);
+    $form['values']['machine_name'] = $form['values']['vocabulary'];
+    $form['values']['vocabulary']['#access'] = FALSE;
+  }
+  elseif ($form['#configurable']->entityType() == 'taxonomy_vocabulary') {
+    unset($form['values']['name']);
+    unset($form['values']['machine_name']);
+    unset($form['values']['vid']);
+  }
+}
+
+/**
+ * Validation callback for taxonomy_form_feedsentityprocessor_feeds_form_alter().
+ */
+function taxonomy_form_feedsentityprocessor_feeds_form_validate(&$form, &$form_state) {
+  if (empty($form_state['values']['values']['weight'])) {
+    form_set_value($form['values']['weight'], 0, $form_state);
+  }
+  form_set_value($form['values']['vocabulary'], $form_state['values']['values']['machine_name'], $form_state);
+}
diff --git a/mappers/file.inc b/mappers/file.inc
index e9cbc26..3e015c9 100644
--- a/mappers/file.inc
+++ b/mappers/file.inc
@@ -21,6 +21,8 @@ function file_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
         'callback' => 'file_feeds_set_target',
         'description' => t('The URI of the @label field.', array('@label' => $instance['label'])),
         'real_target' => $name,
+        'summary_callback' => 'feeds_mapper_summary_language',
+        'form_callback' => 'feeds_mapper_form_language',
       );
 
       if ($info['type'] == 'image') {
@@ -29,12 +31,16 @@ function file_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
           'callback' => 'file_feeds_set_target',
           'description' => t('The alt tag of the @label field.', array('@label' => $instance['label'])),
           'real_target' => $name,
+          'summary_callback' => 'feeds_mapper_summary_language',
+          'form_callback' => 'feeds_mapper_form_language',
         );
         $targets[$name . ':title'] = array(
           'name' => t('@label: Title', array('@label' => $instance['label'])),
           'callback' => 'file_feeds_set_target',
           'description' => t('The title of the @label field.', array('@label' => $instance['label'])),
           'real_target' => $name,
+          'summary_callback' => 'feeds_mapper_summary_language',
+          'form_callback' => 'feeds_mapper_form_language',
         );
       }
     }
@@ -48,11 +54,14 @@ function file_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
  * user has decided to map to and $value contains the value of the feed item
  * element the user has picked as a source.
  */
-function file_feeds_set_target($source, $entity, $target, array $values) {
+function file_feeds_set_target($source, $entity, $target, array $values, $mapping = array()) {
   // Add default of uri for backwards compatibility.
   list($field_name, $sub_field) = explode(':', $target . ':uri');
   $info = field_info_field($field_name);
 
+  // Set the language of the field depending on the mapping configuration.
+  $langcode = isset($mapping['language']) ? $mapping['language'] : LANGUAGE_NONE;
+
   if ($sub_field == 'uri') {
 
     foreach ($values as $k => $v) {
@@ -84,30 +93,30 @@ function file_feeds_set_target($source, $entity, $target, array $values) {
   }
 
   // Populate entity.
-  $field = isset($entity->$field_name) ? $entity->$field_name : array(LANGUAGE_NONE => array());
+  $field = isset($entity->$field_name) ? $entity->$field_name : array($langcode => array());
   $delta = 0;
   foreach ($values as $v) {
     if ($info['cardinality'] == $delta) {
       break;
     }
 
-    if (!isset($field[LANGUAGE_NONE][$delta])) {
-      $field[LANGUAGE_NONE][$delta] = array();
+    if (!isset($field[$langcode][$delta])) {
+      $field[$langcode][$delta] = array();
     }
 
     switch ($sub_field) {
       case 'alt':
       case 'title':
-        $field[LANGUAGE_NONE][$delta][$sub_field] = $v;
+        $field[$langcode][$delta][$sub_field] = $v;
         break;
 
       case 'uri':
         if ($v) {
           try {
             $file = $v->getFile($destination);
-            $field[LANGUAGE_NONE][$delta] += (array) $file;
+            $field[$langcode][$delta] += (array) $file;
             // @todo: Figure out how to properly populate this field.
-            $field[LANGUAGE_NONE][$delta]['display'] = 1;
+            $field[$langcode][$delta]['display'] = 1;
           }
           catch (Exception $e) {
             watchdog_exception('Feeds', $e, nl2br(check_plain($e)));
diff --git a/mappers/link.inc b/mappers/link.inc
index 90b5268..54254a1 100644
--- a/mappers/link.inc
+++ b/mappers/link.inc
@@ -20,6 +20,8 @@ function link_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
           'callback' => 'link_feeds_set_target',
           'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
           'real_target' => $name,
+          'summary_callback' => 'feeds_mapper_summary_language',
+          'form_callback' => 'feeds_mapper_form_language',
         );
       }
       if (array_key_exists('title', $info['columns'])) {
@@ -28,6 +30,8 @@ function link_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
           'callback' => 'link_feeds_set_target',
           'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
           'real_target' => $name,
+          'summary_callback' => 'feeds_mapper_summary_language',
+          'form_callback' => 'feeds_mapper_form_language',
         );
       }
     }
@@ -41,19 +45,22 @@ function link_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
  * user has decided to map to and $value contains the value of the feed item
  * element the user has picked as a source.
  */
-function link_feeds_set_target($source, $entity, $target, array $values) {
+function link_feeds_set_target($source, $entity, $target, array $values, $mapping = array()) {
   list($field_name, $column) = explode(':', $target);
 
   $field = isset($entity->$field_name) ? $entity->$field_name : array('und' => array());
   $delta = 0;
 
+  // Set the language of the field depending on the mapping configuration.
+  $langcode = isset($mapping['language']) ? $mapping['language'] : LANGUAGE_NONE;
+
   foreach ($values as $value) {
     if (is_object($value) && ($value instanceof FeedsElement)) {
       $value = $value->getValue();
     }
 
     if (is_scalar($value)) {
-      $field['und'][$delta][$column] = (string) $value;
+      $field[$langcode][$delta][$column] = (string) $value;
     }
     $delta++;
   }
diff --git a/mappers/number.inc b/mappers/number.inc
index 338d569..7ed7e72 100644
--- a/mappers/number.inc
+++ b/mappers/number.inc
@@ -27,6 +27,8 @@ function number_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_n
         'name' => check_plain($instance['label']),
         'callback' => 'number_feeds_set_target',
         'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
+        'summary_callback' => 'feeds_mapper_summary_language',
+        'form_callback' => 'feeds_mapper_form_language',
       );
     }
   }
@@ -37,9 +39,17 @@ function number_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_n
  *
  * Ensure that $value is a numeric to avoid database errors.
  */
-function number_feeds_set_target($source, $entity, $target, array $values) {
+function number_feeds_set_target($source, $entity, $target, array $values, $mapping = array()) {
+  // Set the language of the field depending on the mapping configuration.
+  $langcode = isset($mapping['language']) ? $mapping['language'] : LANGUAGE_NONE;
+
   // Iterate over all values.
-  $field = isset($entity->$target) ? $entity->$target : array('und' => array());
+  $field = isset($entity->$target) ? $entity->$target : array($langcode => array());
+
+  // If it's a new language we need to add it to the field
+  if (!isset($field[$langcode])) {
+    $field[$langcode] = array();
+  }
 
   foreach ($values as $value) {
 
@@ -48,7 +58,7 @@ function number_feeds_set_target($source, $entity, $target, array $values) {
     }
 
     if (is_numeric($value)) {
-      $field['und'][] = array('value' => $value);
+      $field[$langcode][] = array('value' => $value);
     }
   }
 
diff --git a/mappers/taxonomy.inc b/mappers/taxonomy.inc
index 1a83e0b..636616c 100644
--- a/mappers/taxonomy.inc
+++ b/mappers/taxonomy.inc
@@ -87,7 +87,10 @@ function taxonomy_feeds_set_target($source, $entity, $target, array $terms, $map
   $mapping += array(
     'term_search' => FEEDS_TAXONOMY_SEARCH_TERM_NAME,
     'autocreate' => FALSE,
+    'language' => LANGUAGE_NONE,
   );
+  // Grab the language for convenience
+  $langcode = $mapping['language'];
 
   $info = field_info_field($target);
 
@@ -110,10 +113,15 @@ function taxonomy_feeds_set_target($source, $entity, $target, array $terms, $map
     ->range(0, 1);
 
 
-  $field = isset($entity->$target) ? $entity->$target : array('und' => array());
+  $field = isset($entity->$target) ? $entity->$target : array($langcode => array());
+
+  // If it's a new language we need to add it to the field
+  if (!isset($field[$langcode])) {
+    $field[$langcode] = array();
+  }
 
   // Allow for multiple mappings to the same target.
-  $delta = count($field['und']);
+  $delta = count($field[$langcode]);
 
   // Iterate over all values.
   foreach ($terms as $term) {
@@ -173,7 +181,7 @@ function taxonomy_feeds_set_target($source, $entity, $target, array $terms, $map
     }
 
     if ($tid && isset($cache['allowed_values'][$target][$tid])) {
-      $field['und'][] = array('tid' => $tid);
+      $field[$langcode][] = array('tid' => $tid);
       $delta++;
     }
   }
@@ -264,11 +272,21 @@ function taxonomy_feeds_term_lookup_term_by_guid($guid) {
  *   will be displayed.
  */
 function taxonomy_feeds_summary_callback($mapping, $target, $form, $form_state) {
+  $output = '';
   $options = _taxonomy_feeds_form_callback_options();
   if (empty($mapping['term_search'])) {
-    return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[FEEDS_TAXONOMY_SEARCH_TERM_NAME]));
+    $output = t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[FEEDS_TAXONOMY_SEARCH_TERM_NAME]));
+  }
+  else {
+    $output = t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[$mapping['term_search']]));
+  }
+  if ($language_summary = feeds_mapper_summary_language($mapping, $target, $form, $form_state)) {
+    $output .= '<br/>' . $language_summary;
   }
-  return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[$mapping['term_search']]));
+  if (!empty($mapping['autocreate'])) {
+    $output .= '<br/>' . t('Autocreate Terms: <strong>Yes</strong>');
+  }
+  return $output;
 }
 
 /**
@@ -279,7 +297,8 @@ function taxonomy_feeds_summary_callback($mapping, $target, $form, $form_state)
  *   be populated with the form values.
  */
 function taxonomy_feeds_form_callback($mapping, $target, $form, $form_state) {
-  return array(
+  $return = feeds_mapper_form_language($mapping, $target, $form, $form_state);
+  $return += array(
     'term_search' => array(
       '#type' => 'select',
       '#title' => t('Search taxonomy terms by'),
@@ -298,6 +317,8 @@ function taxonomy_feeds_form_callback($mapping, $target, $form, $form_state) {
       ),
     ),
   );
+
+  return $return;
 }
 
 /**
diff --git a/mappers/taxonomy.inc.orig b/mappers/taxonomy.inc.orig
new file mode 100644
index 0000000..1a83e0b
--- /dev/null
+++ b/mappers/taxonomy.inc.orig
@@ -0,0 +1,315 @@
+<?php
+
+/**
+ * @file
+ * On behalf implementation of Feeds mapping API for taxonomy.module.
+ */
+
+/**
+ * Search by term name.
+ */
+define('FEEDS_TAXONOMY_SEARCH_TERM_NAME', 0);
+
+/**
+ * Search by term id.
+ */
+define('FEEDS_TAXONOMY_SEARCH_TERM_ID', 1);
+
+/**
+ * Search by GUID.
+ */
+define('FEEDS_TAXONOMY_SEARCH_TERM_GUID', 2);
+
+/**
+ * Implements hook_feeds_parser_sources_alter().
+ */
+function taxonomy_feeds_parser_sources_alter(&$sources, $content_type) {
+  if (!empty($content_type)) {
+    foreach (taxonomy_get_vocabularies($content_type) as $vocabulary) {
+      $sources['parent:taxonomy:' . $vocabulary->machine_name] = array(
+        'name' => t('Feed node: Taxonomy: @vocabulary', array('@vocabulary' => $vocabulary->name)),
+        'description' => t('Taxonomy terms from feed node in given vocabulary.'),
+        'callback' => 'taxonomy_feeds_get_source',
+      );
+    }
+  }
+}
+
+/**
+ * Callback, returns taxonomy from feed node.
+ */
+function taxonomy_feeds_get_source(FeedsSource $source, FeedsParserResult $result, $key) {
+  if ($node = node_load($source->feed_nid)) {
+    $terms = taxonomy_feeds_node_get_terms($node);
+    $vocabularies = taxonomy_vocabulary_load_multiple(array(), array('machine_name' => str_replace('parent:taxonomy:', '', $key)));
+    $vocabulary = array_shift($vocabularies);
+    $result = array();
+    foreach ($terms as $tid => $term) {
+      if ($term->vid == $vocabulary->vid) {
+        $result[] = new FeedsTermElement($term);
+      }
+    }
+
+    return $result;
+  }
+}
+
+/**
+ * Implements hook_feeds_processor_targets_alter().
+ */
+function taxonomy_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
+  foreach (field_info_instances($entity_type, $bundle_name) as $name => $instance) {
+    $info = field_info_field($name);
+    if ($info['type'] == 'taxonomy_term_reference') {
+      $targets[$name] = array(
+        'name' => check_plain($instance['label']),
+        'callback' => 'taxonomy_feeds_set_target',
+        'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
+        'summary_callback' => 'taxonomy_feeds_summary_callback',
+        'form_callback' => 'taxonomy_feeds_form_callback',
+      );
+    }
+  }
+  if ($entity_type == 'taxonomy_term') {
+    $targets['tid']['name'] = t('Term id');
+    $targets['tid']['description'] = t('The tid of the taxonomy term. NOTE: use this feature with care, node ids are usually assigned by Drupal.');
+    unset($targets['vocabulary']);
+  }
+}
+
+/**
+ * Callback for mapping. Here is where the actual mapping happens.
+ *
+ * @todo Do not create new terms for non-autotag fields.
+ */
+function taxonomy_feeds_set_target($source, $entity, $target, array $terms, $mapping = array()) {
+  // Add in default values.
+  $mapping += array(
+    'term_search' => FEEDS_TAXONOMY_SEARCH_TERM_NAME,
+    'autocreate' => FALSE,
+  );
+
+  $info = field_info_field($target);
+
+  $cache = &drupal_static(__FUNCTION__);
+  if (!isset($cache['allowed_values'][$target])) {
+    $cache['allowed_values'][$target] = taxonomy_allowed_values($info);
+  }
+
+  if (!isset($cache['allowed_vocabularies'][$target])) {
+    foreach ($info['settings']['allowed_values'] as $tree) {
+      if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
+        $cache['allowed_vocabularies'][$target][$vocabulary->vid] = $vocabulary->machine_name;
+      }
+    }
+  }
+
+  $query = new EntityFieldQuery();
+  $query->entityCondition('entity_type', 'taxonomy_term')
+    ->entityCondition('bundle', $cache['allowed_vocabularies'][$target])
+    ->range(0, 1);
+
+
+  $field = isset($entity->$target) ? $entity->$target : array('und' => array());
+
+  // Allow for multiple mappings to the same target.
+  $delta = count($field['und']);
+
+  // Iterate over all values.
+  foreach ($terms as $term) {
+
+    if ($info['cardinality'] == $delta) {
+      break;
+    }
+
+    $tid = FALSE;
+
+    // FeedsTermElement already is a term.
+    if ($term instanceof FeedsTermElement) {
+      $tid = $term->tid;
+    }
+    else {
+      switch ($mapping['term_search']) {
+
+        // Lookup by name.
+        case FEEDS_TAXONOMY_SEARCH_TERM_NAME:
+          $term = trim($term);
+          $name_query = clone $query;
+          if (strlen($term) && $tids = $name_query->propertyCondition('name', $term)->execute()) {
+
+            // Find the first allowed term.
+            foreach ($tids['taxonomy_term'] as $possible_term) {
+              if (isset($cache['allowed_values'][$target][$possible_term->tid])) {
+                $tid = $possible_term->tid;
+                break;
+              }
+            }
+          }
+          elseif ($mapping['autocreate'] && strlen($term)) {
+            $term = (object) array(
+              'name' => drupal_substr($term, 0, 255),
+              'vid' => key($cache['allowed_vocabularies'][$target]),
+              'vocabulary_machine_name' => reset($cache['allowed_vocabularies'][$target]),
+            );
+            taxonomy_term_save($term);
+            $tid = $term->tid;
+            // Add to the list of allowed values.
+            $cache['allowed_values'][$target][$tid] = $term->name;
+          }
+          break;
+
+        // Lookup by tid.
+        case FEEDS_TAXONOMY_SEARCH_TERM_ID:
+          if (is_numeric($term)) {
+            $tid = (int) $term;
+          }
+          break;
+
+        // Lookup by GUID.
+        case FEEDS_TAXONOMY_SEARCH_TERM_GUID:
+          $tid = taxonomy_feeds_term_lookup_term_by_guid($term);
+          break;
+      }
+    }
+
+    if ($tid && isset($cache['allowed_values'][$target][$tid])) {
+      $field['und'][] = array('tid' => $tid);
+      $delta++;
+    }
+  }
+
+  $entity->$target = $field;
+}
+
+/**
+ * Finds all terms associated with the given node, within one vocabulary.
+ */
+function taxonomy_feeds_node_get_terms($node, $key = 'tid') {
+  $terms = &drupal_static(__FUNCTION__);
+
+  if (!isset($terms[$node->nid][$key])) {
+    // Get tids from all taxonomy_term_reference fields.
+    $tids = array();
+    $fields = field_info_fields();
+    foreach ($fields as $field_name => $field) {
+      if ($field['type'] == 'taxonomy_term_reference' && field_info_instance('node', $field_name, $node->type)) {
+        if (($items = field_get_items('node', $node, $field_name)) && is_array($items)) {
+          $tids = array_merge($tids, array_map('_taxonomy_feeds_extract_tid', $items));
+        }
+      }
+    }
+
+    // Load terms and cache them in static var.
+    $curr_terms = taxonomy_term_load_multiple($tids);
+    $terms[$node->nid][$key] = array();
+    foreach ($curr_terms as $term) {
+      $terms[$node->nid][$key][$term->$key] = $term;
+    }
+  }
+  return $terms[$node->nid][$key];
+}
+
+/**
+ * Extracts tid from array item returned by field_get_items().
+ *
+ * @param array $item
+ *   Tid information in the form of a single element array
+ *   (key == 'tid', value == tid we're looking for)
+ *
+ * @return int
+ *   Term id extracted from $item.
+ *
+ * @see taxonomy_feeds_node_get_terms()
+ * @see field_get_items()
+ */
+function _taxonomy_feeds_extract_tid($item) {
+  return $item['tid'];
+}
+
+/**
+ * Looks up a term by GUID, assumes SQL storage backend.
+ *
+ * @param string $guid
+ *   The Feeds GUID to compare against.
+ *
+ * @return int|FALSE
+ *   The term id, or FALSE if one was not found.
+ */
+function taxonomy_feeds_term_lookup_term_by_guid($guid) {
+  return db_select('feeds_item')
+    ->fields('feeds_item', array('entity_id'))
+    ->condition('entity_type', 'taxonomy_term')
+    ->condition('guid', $guid)
+    ->execute()
+    ->fetchField();
+}
+
+/**
+ * Mapping configuration summary for taxonomy.module.
+ *
+ * @param array $mapping
+ *   Associative array of the mapping settings.
+ * @param array $target
+ *   Array of target settings, as defined by the processor or
+ *   hook_feeds_processor_targets_alter().
+ * @param array $form
+ *   The whole mapping form.
+ * @param array $form_state
+ *   The form state of the mapping form.
+ *
+ * @return string
+ *   Returns, as a string that may contain HTML, the summary to display while
+ *   the full form isn't visible.
+ *   If the return value is empty, no summary and no option to view the form
+ *   will be displayed.
+ */
+function taxonomy_feeds_summary_callback($mapping, $target, $form, $form_state) {
+  $options = _taxonomy_feeds_form_callback_options();
+  if (empty($mapping['term_search'])) {
+    return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[FEEDS_TAXONOMY_SEARCH_TERM_NAME]));
+  }
+  return t('Search taxonomy terms by: <strong>@search</strong>', array('@search' => $options[$mapping['term_search']]));
+}
+
+/**
+ * Settings form callback.
+ *
+ * @return array
+ *   The per mapping configuration form. Once the form is saved, $mapping will
+ *   be populated with the form values.
+ */
+function taxonomy_feeds_form_callback($mapping, $target, $form, $form_state) {
+  return array(
+    'term_search' => array(
+      '#type' => 'select',
+      '#title' => t('Search taxonomy terms by'),
+      '#options' => _taxonomy_feeds_form_callback_options(),
+      '#default_value' => !empty($mapping['term_search']) ? $mapping['term_search'] : FEEDS_TAXONOMY_SEARCH_TERM_NAME,
+    ),
+    'autocreate' => array(
+      '#type' => 'checkbox',
+      '#title' => t('Auto create'),
+      '#description' => t("Create the term if it doesn't exist."),
+      '#default_value' => !empty($mapping['autocreate']) ? $mapping['autocreate'] : 0,
+      '#states' => array(
+        'visible' => array(
+          ':input[name$="[settings][term_search]"]' => array('value' => FEEDS_TAXONOMY_SEARCH_TERM_NAME),
+        ),
+      ),
+    ),
+  );
+}
+
+/**
+ * Returns the list of available term search methods.
+ *
+ * @return array
+ *   An array of taxonomy search option titles.
+ */
+function _taxonomy_feeds_form_callback_options() {
+  return array(
+    FEEDS_TAXONOMY_SEARCH_TERM_NAME => 'Term name',
+    FEEDS_TAXONOMY_SEARCH_TERM_ID => 'Term ID',
+    FEEDS_TAXONOMY_SEARCH_TERM_GUID => 'GUID',
+  );
+}
diff --git a/mappers/text.inc b/mappers/text.inc
index 235aea3..57aaafc 100644
--- a/mappers/text.inc
+++ b/mappers/text.inc
@@ -25,6 +25,8 @@ function text_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_nam
         'name' => check_plain($instance['label']),
         'callback' => 'text_feeds_set_target',
         'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
+        'summary_callback' => 'feeds_mapper_summary_language',
+        'form_callback' => 'feeds_mapper_form_language',
       );
       if ($info['type'] == 'text_with_summary') {
         // Allow mapping to summary.
@@ -58,7 +60,15 @@ function text_feeds_set_target(FeedsSource $source, $entity, $target, array $val
     );
   }
 
-  $field = isset($entity->$field_name) ? $entity->$field_name : array('und' => array());
+  // Set the language of the field depending on the mapping configuration.
+  $langcode = isset($mapping['language']) ? $mapping['language'] : LANGUAGE_NONE;
+
+  $field = isset($entity->$target) ? $entity->$target : array($langcode => array());
+
+  // If it's a new language we need to add it to the field
+  if (!isset($field[$langcode])) {
+    $field[$langcode] = array();
+  }
 
   // Iterate over all values.
   $delta = 0;
@@ -70,10 +80,10 @@ function text_feeds_set_target(FeedsSource $source, $entity, $target, array $val
 
     if (is_scalar($value) && strlen($value)) {
 
-      $field['und'][$delta][$column] = (string) $value;
+      $field[$langcode][$delta][$column] = (string) $value;
 
       if (isset($mapping['format'])) {
-        $field['und'][$delta]['format'] = $mapping['format'];
+        $field[$langcode][$delta]['format'] = $mapping['format'];
       }
     }
 
@@ -102,7 +112,12 @@ function text_feeds_summary_callback(array $mapping, $target, array $form, array
     'format' => $default_format,
   );
 
-  return t('Text format: %format', array('%format' => $formats[$mapping['format']]->name));
+  $summary_language = feeds_mapper_summary_language($mapping, $target, $form, $form_state);
+  $summary = t('Text format: %format', array('%format' => $formats[$mapping['format']]->name));
+  if (!empty($summary_language)) {
+    $summary = $summary . ' ' . $summary_language;
+  }
+  return $summary;
 }
 
 /**
@@ -128,6 +143,8 @@ function text_feeds_form_callback(array $mapping, $target, array $form, array $f
     'format' => $default_format,
   );
 
+  $form_language = feeds_mapper_form_language($mapping, $target, $form, $form_state);
+
   return array(
     'format' => array(
       '#type' => 'select',
@@ -135,5 +152,5 @@ function text_feeds_form_callback(array $mapping, $target, array $form, array $f
       '#options' => $formats_options,
       '#default_value' => $mapping['format'],
     ),
-  );
+  ) + $form_language;
 }
diff --git a/plugins/FeedsEntityProcessor.inc b/plugins/FeedsEntityProcessor.inc
index 5125c94..1efe098 100644
--- a/plugins/FeedsEntityProcessor.inc
+++ b/plugins/FeedsEntityProcessor.inc
@@ -136,6 +136,7 @@ class FeedsEntityProcessor extends FeedsProcessor {
       'skip_hash_check' => FALSE,
       'bundle' => NULL,
       'values' => array(),
+      'language' => LANGUAGE_NONE,
     );
   }
 
diff --git a/plugins/FeedsEntityProcessor.inc.orig b/plugins/FeedsEntityProcessor.inc.orig
new file mode 100644
index 0000000..5125c94
--- /dev/null
+++ b/plugins/FeedsEntityProcessor.inc.orig
@@ -0,0 +1,270 @@
+<?php
+/**
+ * @file
+ * Class definition of FeedsEntityProcessor.
+ */
+
+/**
+ * Creates entities from feed items.
+ */
+class FeedsEntityProcessor extends FeedsProcessor {
+
+  /**
+   * Returns the entity type.
+   *
+   * @return string
+   *   The type of entity this processor will create.
+   */
+  public function entityType() {
+    $plugin_info = $this->pluginDefinition();
+    return $plugin_info['type'];
+  }
+
+  /**
+   * Returns the bundle.
+   *
+   * @return string
+   *   The bundle of the entities this processor will create.
+   */
+  public function bundle() {
+    $bundle = $this->entityType();
+
+    $entity_info = $this->entityInfo();
+    if(!empty($this->config['bundle']) && isset($entity_info['bundles'][$this->config['bundle']])) {
+      $bundle = $this->config['bundle'];
+    }
+
+    return $bundle;
+  }
+
+  /**
+   * Overrides parent::entityInfo().
+   */
+  protected function entityInfo() {
+    $info = parent::entityInfo();
+    if (isset($info['label plural'])) {
+      $plural = $info['label plural'];
+    }
+    else {
+      $plural = $info['label'];
+    }
+
+    $info += array('label plural' => $plural);
+    return $info;
+  }
+
+  /**
+   * Creates a new entity in memory and returns it.
+   */
+  protected function newEntity(FeedsSource $source) {
+    $info = $this->entityInfo();
+    $values = $this->config['values'];
+
+    if (isset($info['entity keys']['bundle']) && isset($this->config['bundle'])) {
+      $values[$info['entity keys']['bundle']] = $this->config['bundle'];
+    }
+
+    return entity_create($this->entityType(), $values);
+  }
+
+  /**
+   * Check that the user has permission to save an entity.
+   *
+   * @todo Is checking the uid safe? A quick glance through core and some
+   *   contrib seems to say yes.
+   */
+  protected function entitySaveAccess($entity) {
+
+    // The check will be skipped for anonymous users.
+    if (!empty($this->config['authorize']) && !empty($entity->uid)) {
+
+      $author = user_load($entity->uid);
+
+      // If the uid was mapped directly, rather than by email or username, it
+      // could be invalid.
+      if (!$author) {
+        $message = 'User %uid is not a valid user.';
+        throw new FeedsAccessException(t($message, array('%uid' => $entity->uid)));
+      }
+
+      if (!empty($entity->is_new)) {
+        $op = 'create';
+        $access = entity_access($op, $this->entityType(), $author);
+      }
+      else {
+        $op = 'update';
+        $access = entity_access($op, $this->entityType(), $author);
+      }
+
+      if (!$access) {
+        $message = t('The user %name is not authorized to %op entity %entity_type. To import this item, the user "@name" (owner of the item) must be given the permission to @op entity @entity_type.', array(
+          '%name' => $author->name,
+          '%op' => $op,
+          '%entity_type' => $this->entityType(),
+          '@name' => $author->name,
+          '@op' => $op,
+          '@entity_type' => $this->entityType(),
+        ));
+        throw new FeedsAccessException($message);
+      }
+    }
+  }
+
+  /**
+   * Save a entity.
+   */
+  public function entitysave($entity) {
+    entity_save($this->entityType(), $entity);
+  }
+
+  /**
+   * Delete a series of entities.
+   */
+  protected function entityDeleteMultiple($ids) {
+    entity_delete_multiple($this->entityType(), $ids);
+  }
+
+  /**
+   * Override parent::configDefaults().
+   */
+  public function configDefaults() {
+    return array(
+      'mappings' => array(),
+      'update_existing' => FEEDS_SKIP_EXISTING,
+      'update_non_existent' => FEEDS_SKIP_NON_EXISTENT,
+      'input_format' => NULL,
+      'skip_hash_check' => FALSE,
+      'bundle' => NULL,
+      'values' => array(),
+    );
+  }
+
+  /**
+   * Override parent::configForm().
+   */
+  public function configForm(&$form_state) {
+    $form = parent::configForm($form_state);
+
+    $form['values'] = array(
+      '#type' => 'fieldset',
+      '#title' => t('Default values'),
+      '#tree' => TRUE,
+      '#description' => t('Most of the values below can be overriden by mapping a value.'),
+    );
+
+    $entity_info = $this->entityInfo();
+    $label_plural = $entity_info['label plural'];
+
+    $form['input_format']['#description'] = t('Select the default input format for the %entity to be created.', array('%entity' => $label_plural));
+
+    $wrapper = entity_metadata_wrapper($this->entityType());
+
+    $bundle_key = !empty($entity_info['entity keys']['bundle']) ? $entity_info['entity keys']['bundle']: NULL;
+
+    foreach ($wrapper->getPropertyInfo() as $name => $property) {
+      if ($name == $bundle_key) {
+        continue;
+      }
+
+      if (!empty($property['setter callback']) && empty($property['field'])) {
+        $form['values'][$name] = array(
+          '#type' => 'textfield',
+          '#title' => $property['label'],
+          '#description' => isset($property['description']) ? $property['description'] : '',
+          '#default_value' => isset($this->config['values'][$name]) ? $this->config['values'][$name] : NULL,
+          '#required' => !empty($property['required']),
+        );
+
+        if (!empty($property['options list'])) {
+          $form['values'][$name]['#type'] = 'select';
+          if (isset($property['type']) && entity_property_list_extract_type($property['type'])) {
+            $form['values'][$name]['#type'] = 'checkboxes';
+            if (!is_array($form['values'][$name]['#default_value'])) {
+              $form['values'][$name]['#default_value'] = array($form['values'][$name]['#default_value']);
+            }
+          }
+          $form['values'][$name]['#options'] = $wrapper->$name->optionsList();
+        }
+
+        elseif (!empty($property['type']) && $property['type'] == 'boolean') {
+          $form['values'][$name]['#type'] = 'checkbox';
+        }
+        // elseif (!empty($property['type']) && $property['type'] == 'date') {
+        //   $form['values'][$name]['#type'] = 'date';
+        // }
+      }
+    }
+    return $form;
+  }
+
+  /**
+   * Override parent::configFormValidate().
+   */
+  public function configFormValidate(&$values) {
+    $form = parent::configFormValidate($values);
+
+    $wrapper = entity_metadata_wrapper($this->entityType());
+
+    foreach ($wrapper->getPropertyInfo() as $name => $property) {
+      if (!empty($property['setter callback']) && empty($property['field'])) {
+
+        // Entity api won't accept empty date values.
+        if (!empty($property['type']) && $property['type'] == 'date') {
+          if (empty($values['values'][$name])) {
+            unset($values['values'][$name]);
+            continue;
+          }
+        }
+
+        if (isset($property['type']) && array_key_exists($name, $values['values'])) {
+          if (entity_property_list_extract_type($property['type']) && !is_array($values['values'][$name])) {
+            $values['values'][$name] = array($values['values'][$name]);
+          }
+          // check if values empty first as all default values are optional
+          if (!empty($values['values'][$name])) {
+            $valid = entity_property_verify_data_type($values['values'][$name], $property['type']);
+            if (!$valid) {
+              form_set_error("values][$name", t('Invalid data value given. Be sure it matches the required data type and format.'));
+            }
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns available mapping targets.
+   */
+  public function getMappingTargets() {
+    // Get a wrapper with the right bundle info.
+
+    $targets = parent::getMappingTargets();
+    $info = array('bundle' => $this->bundle());
+
+    $wrapper = entity_metadata_wrapper($this->entityType(), NULL, $info);
+    // @todo: maybe restrict to data types feeds can deal with.
+    foreach ($wrapper->getPropertyInfo() as $name => $property) {
+      if (empty($property['field'])) {
+        $targets[$name] = array(
+          'name' => $property['label'],
+          'description' => isset($property['description']) ? $property['description'] : NULL,
+        );
+      }
+    }
+
+    $entity_info = $this->entityInfo();
+    $targets[$entity_info['entity keys']['id']]['optional_unique'] = TRUE;
+
+    // Remove the bundle target.
+    if (isset($entity_info['bundle keys']['bundle'])) {
+      unset($targets[$entity_info['bundle keys']['bundle']]);
+    }
+
+    // Let other modules expose mapping targets.
+    self::loadMappers();
+    $type = $this->entityType();
+    drupal_alter('feeds_processor_targets', $targets, $type, $info['bundle']);
+
+    return $targets;
+  }
+}
diff --git a/plugins/FeedsNodeProcessor.inc b/plugins/FeedsNodeProcessor.inc
index d3d3bb4..5a87dc0 100644
--- a/plugins/FeedsNodeProcessor.inc
+++ b/plugins/FeedsNodeProcessor.inc
@@ -40,7 +40,6 @@ class FeedsNodeProcessor extends FeedsProcessor {
     $node->type = $this->bundle();
     $node->changed = REQUEST_TIME;
     $node->created = REQUEST_TIME;
-    $node->language = LANGUAGE_NONE;
     $node->is_new = TRUE;
     node_object_prepare($node);
     // Populate properties that are set by node_object_prepare().
diff --git a/plugins/FeedsNodeProcessor.inc.orig b/plugins/FeedsNodeProcessor.inc.orig
new file mode 100644
index 0000000..d3d3bb4
--- /dev/null
+++ b/plugins/FeedsNodeProcessor.inc.orig
@@ -0,0 +1,411 @@
+<?php
+
+/**
+ * @file
+ * Class definition of FeedsNodeProcessor.
+ */
+
+/**
+ * Option for handling content in Drupal but not in source data (unpublish
+ * instead of skip/delete).
+ */
+define('FEEDS_UNPUBLISH_NON_EXISTENT', 'unpublish');
+
+/**
+ * Creates nodes from feed items.
+ */
+class FeedsNodeProcessor extends FeedsProcessor {
+
+  /**
+   * Define entity type.
+   */
+  public function entityType() {
+    return 'node';
+  }
+
+  /**
+   * Implements parent::entityInfo().
+   */
+  protected function entityInfo() {
+    $info = parent::entityInfo();
+    $info['label plural'] = t('Nodes');
+    return $info;
+  }
+
+  /**
+   * Creates a new node in memory and returns it.
+   */
+  protected function newEntity(FeedsSource $source) {
+    $node = new stdClass();
+    $node->type = $this->bundle();
+    $node->changed = REQUEST_TIME;
+    $node->created = REQUEST_TIME;
+    $node->language = LANGUAGE_NONE;
+    $node->is_new = TRUE;
+    node_object_prepare($node);
+    // Populate properties that are set by node_object_prepare().
+    $node->log = 'Created by FeedsNodeProcessor';
+    $node->uid = $this->config['author'];
+    return $node;
+  }
+
+  /**
+   * Loads an existing node.
+   *
+   * If the update existing method is not FEEDS_UPDATE_EXISTING, only the node
+   * table will be loaded, foregoing the node_load API for better performance.
+   *
+   * @todo Reevaluate the use of node_object_prepare().
+   */
+  protected function entityLoad(FeedsSource $source, $nid) {
+    $node = parent::entityLoad($source, $nid);
+
+    if ($this->config['update_existing'] != FEEDS_UPDATE_EXISTING) {
+      $node->uid = $this->config['author'];
+    }
+
+    node_object_prepare($node);
+
+    // Workaround for issue #1247506. See #1245094 for backstory.
+    if (!empty($node->menu)) {
+      // If the node has a menu item(with a valid mlid) it must be flagged
+      // 'enabled'.
+      $node->menu['enabled'] = (int) (bool) $node->menu['mlid'];
+    }
+
+    // Populate properties that are set by node_object_prepare().
+    if ($this->config['update_existing'] == FEEDS_UPDATE_EXISTING) {
+      $node->log = 'Updated by FeedsNodeProcessor';
+    }
+    else {
+      $node->log = 'Replaced by FeedsNodeProcessor';
+    }
+    return $node;
+  }
+
+  /**
+   * Check that the user has permission to save a node.
+   */
+  protected function entitySaveAccess($entity) {
+
+    // The check will be skipped for anonymous nodes.
+    if ($this->config['authorize'] && !empty($entity->uid)) {
+
+      $author = user_load($entity->uid);
+
+      // If the uid was mapped directly, rather than by email or username, it
+      // could be invalid.
+      if (!$author) {
+        $message = 'User %uid is not a valid user.';
+        throw new FeedsAccessException(t($message, array('%uid' => $entity->uid)));
+      }
+
+      if (empty($entity->nid) || !empty($entity->is_new)) {
+        $op = 'create';
+        $access = node_access($op, $entity->type, $author);
+      }
+      else {
+        $op = 'update';
+        $access = node_access($op, $entity, $author);
+      }
+
+      if (!$access) {
+        $message = t('The user %name is not authorized to %op content of type %content_type. To import this item, either the user "@name" (author of the item) must be given the permission to @op content of type @content_type, or the option "Authorize" on the Node processor settings must be turned off.', array(
+          '%name' => $author->name,
+          '%op' => $op,
+          '%content_type' => $entity->type,
+          '@name' => $author->name,
+          '@op' => $op,
+          '@content_type' => $entity->type,
+        ));
+        throw new FeedsAccessException($message);
+      }
+    }
+  }
+
+  /**
+   * Validates a node.
+   */
+  protected function entityValidate($entity) {
+    if (!isset($entity->uid) || !is_numeric($entity->uid)) {
+       $entity->uid = $this->config['author'];
+    }
+  }
+
+  /**
+   * Save a node.
+   */
+  public function entitySave($entity) {
+    node_save($entity);
+  }
+
+  /**
+   * Delete a series of nodes.
+   */
+  protected function entityDeleteMultiple($nids) {
+    node_delete_multiple($nids);
+  }
+
+  /**
+   * Overrides parent::expiryQuery().
+   */
+  protected function expiryQuery(FeedsSource $source, $time) {
+    $select = parent::expiryQuery($source, $time);
+    $select->condition('e.created', REQUEST_TIME - $time, '<');
+    return $select;
+  }
+
+  /**
+   * Return expiry time.
+   */
+  public function expiryTime() {
+    return $this->config['expire'];
+  }
+
+  /**
+   * Override parent::configDefaults().
+   */
+  public function configDefaults() {
+    return array(
+      'expire' => FEEDS_EXPIRE_NEVER,
+      'author' => 0,
+      'authorize' => TRUE,
+    ) + parent::configDefaults();
+  }
+
+  /**
+   * Override parent::configForm().
+   */
+  public function configForm(&$form_state) {
+    $form = parent::configForm($form_state);
+
+    $author = user_load($this->config['author']);
+    $form['author'] = array(
+      '#type' => 'textfield',
+      '#title' => t('Author'),
+      '#description' => t('Select the author of the nodes to be created - leave empty to assign "anonymous".'),
+      '#autocomplete_path' => 'user/autocomplete',
+      '#default_value' => empty($author->name) ?  'anonymous' : check_plain($author->name),
+    );
+    $form['authorize'] = array(
+      '#type' => 'checkbox',
+      '#title' => t('Authorize'),
+      '#description' => t('Check that the author has permission to create the node.'),
+      '#default_value' => $this->config['authorize'],
+    );
+    $period = drupal_map_assoc(array(FEEDS_EXPIRE_NEVER, 3600, 10800, 21600, 43200, 86400, 259200, 604800, 2592000, 2592000 * 3, 2592000 * 6, 31536000), 'feeds_format_expire');
+    $form['expire'] = array(
+      '#type' => 'select',
+      '#title' => t('Expire nodes'),
+      '#options' => $period,
+      '#description' => t("Select after how much time nodes should be deleted. The node's published date will be used for determining the node's age, see Mapping settings."),
+      '#default_value' => $this->config['expire'],
+    );
+    // Add on the "Unpublish" option for nodes, update wording.
+    if (isset($form['update_non_existent'])) {
+      $form['update_non_existent']['#options'][FEEDS_UNPUBLISH_NON_EXISTENT] = t('Unpublish non-existent nodes');
+    }
+    return $form;
+  }
+
+  /**
+   * Override parent::configFormValidate().
+   */
+  public function configFormValidate(&$values) {
+    if ($author = user_load_by_name($values['author'])) {
+      $values['author'] = $author->uid;
+    }
+    else {
+      $values['author'] = 0;
+    }
+  }
+
+  /**
+   * Reschedule if expiry time changes.
+   */
+  public function configFormSubmit(&$values) {
+    if ($this->config['expire'] != $values['expire']) {
+      feeds_reschedule($this->id);
+    }
+    parent::configFormSubmit($values);
+  }
+
+  /**
+   * Override setTargetElement to operate on a target item that is a node.
+   */
+  public function setTargetElement(FeedsSource $source, $target_node, $target_element, $value) {
+    switch ($target_element) {
+      case 'created':
+        $target_node->created = feeds_to_unixtime($value, REQUEST_TIME);
+        break;
+      case 'feeds_source':
+        // Get the class of the feed node importer's fetcher and set the source
+        // property. See feeds_node_update() how $node->feeds gets stored.
+        if ($id = feeds_get_importer_id($this->bundle())) {
+          $class = get_class(feeds_importer($id)->fetcher);
+          $target_node->feeds[$class]['source'] = $value;
+          // This effectively suppresses 'import on submission' feature.
+          // See feeds_node_insert().
+          $target_node->feeds['suppress_import'] = TRUE;
+        }
+        break;
+      case 'user_name':
+        if ($user = user_load_by_name($value)) {
+          $target_node->uid = $user->uid;
+        }
+        break;
+      case 'user_mail':
+        if ($user = user_load_by_mail($value)) {
+          $target_node->uid = $user->uid;
+        }
+        break;
+      default:
+        parent::setTargetElement($source, $target_node, $target_element, $value);
+        break;
+    }
+  }
+
+  /**
+   * Return available mapping targets.
+   */
+  public function getMappingTargets() {
+    $type = node_type_get_type($this->bundle());
+
+    $targets = parent::getMappingTargets();
+    if ($type && $type->has_title) {
+      $targets['title'] = array(
+        'name' => t('Title'),
+        'description' => t('The title of the node.'),
+        'optional_unique' => TRUE,
+      );
+    }
+    $targets['nid'] = array(
+      'name' => t('Node ID'),
+      'description' => t('The nid of the node. NOTE: use this feature with care, node ids are usually assigned by Drupal.'),
+      'optional_unique' => TRUE,
+    );
+    $targets['uid'] = array(
+      'name' => t('User ID'),
+      'description' => t('The Drupal user ID of the node author.'),
+    );
+    $targets['user_name'] = array(
+      'name' => t('Username'),
+      'description' => t('The Drupal username of the node author.'),
+    );
+    $targets['user_mail'] = array(
+      'name' => t('User email'),
+      'description' => t('The email address of the node author.'),
+    );
+    $targets['status'] = array(
+      'name' => t('Published status'),
+      'description' => t('Whether a node is published or not. 1 stands for published, 0 for not published.'),
+    );
+    $targets['created'] = array(
+      'name' => t('Published date'),
+      'description' => t('The UNIX time when a node has been published.'),
+    );
+    $targets['promote'] = array(
+      'name' => t('Promoted to front page'),
+      'description' => t('Boolean value, whether or not node is promoted to front page. (1 = promoted, 0 = not promoted)'),
+    );
+    $targets['sticky'] = array(
+      'name' => t('Sticky'),
+      'description' => t('Boolean value, whether or not node is sticky at top of lists. (1 = sticky, 0 = not sticky)'),
+    );
+
+    // Include language field if Locale module is enabled.
+    if (module_exists('locale')) {
+      $targets['language'] = array(
+        'name' => t('Language'),
+        'description' => t('The two-character language code of the node.'),
+      );
+    }
+
+    // Include comment field if Comment module is enabled.
+    if (module_exists('comment')) {
+      $targets['comment'] = array(
+        'name' => t('Comments'),
+        'description' => t('Whether comments are allowed on this node: 0 = no, 1 = read only, 2 = read/write.'),
+      );
+    }
+
+    // If the target content type is a Feed node, expose its source field.
+    if ($id = feeds_get_importer_id($this->bundle())) {
+      $name = feeds_importer($id)->config['name'];
+      $targets['feeds_source'] = array(
+        'name' => t('Feed source'),
+        'description' => t('The content type created by this processor is a Feed Node, it represents a source itself. Depending on the fetcher selected on the importer "@importer", this field is expected to be for example a URL or a path to a file.', array('@importer' => $name)),
+        'optional_unique' => TRUE,
+      );
+    }
+
+    // Let other modules expose mapping targets.
+    self::loadMappers();
+    $entity_type = $this->entityType();
+    $bundle = $this->bundle();
+    drupal_alter('feeds_processor_targets', $targets, $entity_type, $bundle);
+
+    return $targets;
+  }
+
+  /**
+   * Get nid of an existing feed item node if available.
+   */
+  protected function existingEntityId(FeedsSource $source, FeedsParserResult $result) {
+    if ($nid = parent::existingEntityId($source, $result)) {
+      return $nid;
+    }
+
+    // Iterate through all unique targets and test whether they do already
+    // exist in the database.
+    foreach ($this->uniqueTargets($source, $result) as $target => $value) {
+      switch ($target) {
+        case 'nid':
+          $nid = db_query("SELECT nid FROM {node} WHERE nid = :nid", array(':nid' => $value))->fetchField();
+          break;
+        case 'title':
+          $nid = db_query("SELECT nid FROM {node} WHERE title = :title AND type = :type", array(':title' => $value, ':type' => $this->bundle()))->fetchField();
+          break;
+        case 'feeds_source':
+          if ($id = feeds_get_importer_id($this->bundle())) {
+            $nid = db_query("SELECT fs.feed_nid FROM {node} n JOIN {feeds_source} fs ON n.nid = fs.feed_nid WHERE fs.id = :id AND fs.source = :source", array(':id' => $id, ':source' => $value))->fetchField();
+          }
+          break;
+      }
+      if ($nid) {
+        // Return with the first nid found.
+        return $nid;
+      }
+    }
+    return 0;
+  }
+
+  /**
+   * Overrides FeedsProcessor::clean().
+   *
+   * Allow unpublish instead of delete.
+   *
+   * @param FeedsState $state
+   *   The FeedsState object for the given stage.
+   */
+  protected function clean(FeedsState $state) {
+    // Delegate to parent if not unpublishing or option not set.
+    if (!isset($this->config['update_non_existent']) || $this->config['update_non_existent'] != FEEDS_UNPUBLISH_NON_EXISTENT) {
+      return parent::clean($state);
+    }
+
+    $total = count($state->removeList);
+    if ($total) {
+      $nodes = node_load_multiple($state->removeList);
+      foreach ($nodes as &$node) {
+        if ($node->status == 0) {
+          continue;
+        }
+        node_unpublish_action($node);
+        node_save($node);
+        $state->unpublished++;
+      }
+    }
+  }
+
+}
diff --git a/plugins/FeedsProcessor.inc b/plugins/FeedsProcessor.inc
index e67a244..9f688bc 100755
--- a/plugins/FeedsProcessor.inc
+++ b/plugins/FeedsProcessor.inc
@@ -17,6 +17,9 @@ define('FEEDS_DELETE_NON_EXISTENT', 'delete');
 // processors.
 define('FEEDS_PROCESS_LIMIT', 50);
 
+// Default Language trigger
+define('FEEDS_LANGUAGE_DEFAULT', 'xx_');
+
 /**
  * Thrown if a validation fails.
  */
@@ -80,6 +83,23 @@ abstract class FeedsProcessor extends FeedsPlugin {
   }
 
   /**
+   * Provides a list of language options for use in select lists.
+   *
+   * @return array
+   *   A keyed array of langcode => language.
+   */
+  public function languageOptions() {
+    $options = array(
+      FEEDS_LANGUAGE_DEFAULT => t('Default Language'),
+      LANGUAGE_NONE => t('Language neutral'),
+    );
+    foreach (language_list() as $langcode => $language) {
+      $options[$langcode] = $language->name;
+    }
+    return $options;
+  }
+
+  /**
    * Create a new entity.
    *
    * @param $source
@@ -226,11 +246,16 @@ abstract class FeedsProcessor extends FeedsPlugin {
         // Build a new entity.
         else {
           $entity = $this->newEntity($source);
+          // Set the language if it wasn't set specifically by a processor
+          if (!isset($entity->language)) {
+            $entity->language = $this->getConfigLanguage();
+          }
           $this->newItemInfo($entity, $source->feed_nid, $hash);
         }
 
         // Set property and field values.
         $this->map($source, $parser_result, $entity);
+        $this->processEntityTitleReplacements($entity);
         $this->entityValidate($entity);
 
         // Allow modules to alter the entity before saving.
@@ -246,6 +271,7 @@ abstract class FeedsProcessor extends FeedsPlugin {
 
         // This will throw an exception on failure.
         $this->entitySaveAccess($entity);
+        $this->processTranslations($entity);
         $this->entitySave($entity);
 
         // Allow modules to perform operations using the saved entity data.
@@ -703,6 +729,7 @@ abstract class FeedsProcessor extends FeedsPlugin {
       'input_format' => NULL,
       'skip_hash_check' => FALSE,
       'bundle' => $bundle,
+      'language' => LANGUAGE_NONE,
     );
   }
 
@@ -729,6 +756,14 @@ abstract class FeedsProcessor extends FeedsPlugin {
       );
     }
 
+    $form['language'] = array(
+      '#type' => 'select',
+      '#options' => $this->languageOptions(),
+      '#title' => t('Language'),
+      '#required' => TRUE,
+      '#default_value' => $this->config['language'],
+    );
+
     $tokens = array('@entities' => strtolower($info['label plural']));
 
     $form['update_existing'] = array(
@@ -837,6 +872,101 @@ abstract class FeedsProcessor extends FeedsPlugin {
   }
 
   /**
+   * Returns the configured language for the processor
+   *
+   * @return
+   *   The language code configured for the processor
+   */
+  public function getConfigLanguage() {
+    return ($this->config['language'] == FEEDS_LANGUAGE_DEFAULT) ? language_default('language') : $this->config['language'];
+  }
+
+  /**
+   * Returns the language for the entity.
+   *
+   * @param string $entity
+   *   The entity for which to get the language.
+   *
+   * @return
+   *   The language code for the entity, or the language code that's configured
+   *   for the processor if the entity doesn't have any language support.
+   */
+  public function getEntityLanguage($entity) {
+    $language = entity_language($this->entityType(), $entity);
+    return $language ? $language : $this->getConfigLanguage();
+  }
+
+  /**
+   * Process entity properties that have been replaced with the title module
+   *
+   * @param  object $entity
+   *   The entity to check for replaced properties
+   */
+  public function processEntityTitleReplacements(&$entity) {
+    if (module_exists('title')) {
+      // Get the possible replacements for this entity type
+      if ($replacements = title_field_replacement_info($this->entityType())) {
+        // Loop through replacements
+        foreach ($replacements as $legacy_field => $field_info) {
+          // Populate legacy field with value from the field of the language
+          // for the entity.
+          $language = $this->getEntityLanguage($entity);
+          if (!empty($entity->{$field_info['field']['field_name']}[$language]) && empty($entity->{$legacy_field})) {
+            $entity->{$legacy_field} = $entity->{$field_info['field']['field_name']}[$language][0]['value'];
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Add translations to an entity for each mapped language
+   *
+   * @param  object $entity
+   *   The entity to add translations to
+   */
+  public function processTranslations(&$entity) {
+    // Add translations (if the entity_translation module exists) provided at
+    // least one field has a translation
+    if (module_exists('entity_translation')) {
+      $handler = entity_translation_get_handler($this->entityType(), $entity);
+      $languages = array();
+      $default_langcode = $this->getEntityLanguage($entity);
+
+      // Init the translations if there's not translation data yet
+      if (empty($entity->translations->data)) {
+        $handler->initTranslations();
+      }
+
+      // Loop through the mappings
+      foreach ($this->getMappings() as $mapping) {
+        if (!empty($mapping['language']) && $mapping['language'] != LANGUAGE_NONE && $mapping['language'] != $default_langcode && empty($entity->translations->data[$mapping['language']])) {
+          list($field_name) = explode(':', $mapping['target']);
+
+          // If this field's language has items we create a translation for it
+          if (!empty($entity->{$field_name}[$mapping['language']])) {
+            $translation = array(
+              'translate' => 0,
+              'status' => 1,
+              'language' => $mapping['language'],
+              'source' => $default_langcode,
+            );
+            $handler->setTranslation($translation, $entity);
+          }
+        }
+      }
+
+      // Loop through every language for the site, and remove translations for
+      // the one that hasn't got any values.
+      foreach (language_list() as $language) {
+        if (!isset($entity->translations->data[$language->language])) {
+          $handler->removeTranslation($language->language);
+        }
+      }
+    }
+  }
+
+  /**
    * Retrieve the target entity's existing id if available. Otherwise return 0.
    *
    * @ingroup mappingapi
diff --git a/plugins/FeedsProcessor.inc.orig b/plugins/FeedsProcessor.inc.orig
new file mode 100755
index 0000000..e67a244
--- /dev/null
+++ b/plugins/FeedsProcessor.inc.orig
@@ -0,0 +1,1032 @@
+<?php
+
+/**
+ * @file
+ * Contains FeedsProcessor and related classes.
+ */
+
+// Update mode for existing items.
+define('FEEDS_SKIP_EXISTING', 0);
+define('FEEDS_REPLACE_EXISTING', 1);
+define('FEEDS_UPDATE_EXISTING', 2);
+// Options for handling content in Drupal but not in source data.
+define('FEEDS_SKIP_NON_EXISTENT', 'skip');
+define('FEEDS_DELETE_NON_EXISTENT', 'delete');
+
+// Default limit for creating items on a page load, not respected by all
+// processors.
+define('FEEDS_PROCESS_LIMIT', 50);
+
+/**
+ * Thrown if a validation fails.
+ */
+class FeedsValidationException extends Exception {}
+
+/**
+ * Thrown if a an access check fails.
+ */
+class FeedsAccessException extends Exception {}
+
+/**
+ * Abstract class, defines interface for processors.
+ */
+abstract class FeedsProcessor extends FeedsPlugin {
+
+  /**
+   * Implements FeedsPlugin::pluginType().
+   */
+  public function pluginType() {
+    return 'processor';
+  }
+
+  /**
+   * @defgroup entity_api_wrapper Entity API wrapper.
+   */
+
+  /**
+   * Entity type this processor operates on.
+   */
+  public abstract function entityType();
+
+  /**
+   * Bundle type this processor operates on.
+   *
+   * Defaults to the entity type for entities that do not define bundles.
+   *
+   * @return string|NULL
+   *   The bundle type this processor operates on, or NULL if it is undefined.
+   */
+  public function bundle() {
+    return $this->config['bundle'];
+  }
+
+  /**
+   * Provides a list of bundle options for use in select lists.
+   *
+   * @return array
+   *   A keyed array of bundle => label.
+   */
+  public function bundleOptions() {
+    $options = array();
+    foreach (field_info_bundles($this->entityType()) as $bundle => $info) {
+      if (!empty($info['label'])) {
+        $options[$bundle] = $info['label'];
+      }
+      else {
+        $options[$bundle] = $bundle;
+      }
+    }
+    return $options;
+  }
+
+  /**
+   * Create a new entity.
+   *
+   * @param $source
+   *   The feeds source that spawns this entity.
+   *
+   * @return
+   *   A new entity object.
+   */
+  protected abstract function newEntity(FeedsSource $source);
+
+  /**
+   * Load an existing entity.
+   *
+   * @param $source
+   *   The feeds source that spawns this entity.
+   * @param $entity_id
+   *   The unique id of the entity that should be loaded.
+   *
+   * @return
+   *   A new entity object.
+   *
+   * @todo We should be able to batch load these, if we found all of the
+   *   existing ids first.
+   */
+  protected function entityLoad(FeedsSource $source, $entity_id) {
+    if ($this->config['update_existing'] == FEEDS_UPDATE_EXISTING) {
+      $entities = entity_load($this->entityType(), array($entity_id));
+      return reset($entities);
+    }
+
+    $info = $this->entityInfo();
+
+    $args = array(':entity_id' => $entity_id);
+
+    $table = db_escape_table($info['base table']);
+    $key = db_escape_field($info['entity keys']['id']);
+
+    return db_query("SELECT * FROM {" . $table . "} WHERE $key = :entity_id", $args)->fetchObject();
+  }
+
+  /**
+   * Validate an entity.
+   *
+   * @throws FeedsValidationException $e
+   *   If validation fails.
+   */
+  protected function entityValidate($entity) {}
+
+  /**
+   * Access check for saving an enity.
+   *
+   * @param $entity
+   *   Entity to be saved.
+   *
+   * @throws FeedsAccessException $e
+   *   If the access check fails.
+   */
+  protected function entitySaveAccess($entity) {}
+
+  /**
+   * Save an entity.
+   *
+   * @param $entity
+   *   Entity to be saved.
+   */
+  protected abstract function entitySave($entity);
+
+  /**
+   * Delete a series of entities.
+   *
+   * @param $entity_ids
+   *   Array of unique identity ids to be deleted.
+   */
+  protected abstract function entityDeleteMultiple($entity_ids);
+
+  /**
+   * Wrap entity_get_info() into a method so that extending classes can override
+   * it and more entity information. Allowed additional keys:
+   *
+   * 'label plural' ... the plural label of an entity type.
+   */
+  protected function entityInfo() {
+    return entity_get_info($this->entityType());
+  }
+
+  /**
+   * @}
+   */
+
+  /**
+   * Process the result of the parsing stage.
+   *
+   * @param FeedsSource $source
+   *   Source information about this import.
+   * @param FeedsParserResult $parser_result
+   *   The result of the parsing stage.
+   */
+  public function process(FeedsSource $source, FeedsParserResult $parser_result) {
+    $state = $source->state(FEEDS_PROCESS);
+    if (!isset($state->removeList) && $parser_result->items) {
+      $this->initEntitiesToBeRemoved($source, $state);
+    }
+
+    while ($item = $parser_result->shiftItem()) {
+
+      // Check if this item already exists.
+      $entity_id = $this->existingEntityId($source, $parser_result);
+      // If it's included in the feed, it must not be removed on clean.
+      if ($entity_id) {
+        unset($state->removeList[$entity_id]);
+      }
+      $skip_existing = $this->config['update_existing'] == FEEDS_SKIP_EXISTING;
+
+      module_invoke_all('feeds_before_update', $source, $item, $entity_id);
+
+      // If it exists, and we are not updating, pass onto the next item.
+      if ($entity_id && $skip_existing) {
+        continue;
+      }
+
+      try {
+
+        $hash = $this->hash($item);
+        $changed = ($hash !== $this->getHash($entity_id));
+        $force_update = $this->config['skip_hash_check'];
+
+        // Do not proceed if the item exists, has not changed, and we're not
+        // forcing the update.
+        if ($entity_id && !$changed && !$force_update) {
+          continue;
+        }
+
+        // Load an existing entity.
+        if ($entity_id) {
+          $entity = $this->entityLoad($source, $entity_id);
+
+          // The feeds_item table is always updated with the info for the most
+          // recently processed entity. The only carryover is the entity_id.
+          $this->newItemInfo($entity, $source->feed_nid, $hash);
+          $entity->feeds_item->entity_id = $entity_id;
+          $entity->feeds_item->is_new = FALSE;
+        }
+
+        // Build a new entity.
+        else {
+          $entity = $this->newEntity($source);
+          $this->newItemInfo($entity, $source->feed_nid, $hash);
+        }
+
+        // Set property and field values.
+        $this->map($source, $parser_result, $entity);
+        $this->entityValidate($entity);
+
+        // Allow modules to alter the entity before saving.
+        module_invoke_all('feeds_presave', $source, $entity, $item, $entity_id);
+        if (module_exists('rules')) {
+          rules_invoke_event('feeds_import_'. $source->importer()->id, $entity);
+        }
+
+        // Enable modules to skip saving at all.
+        if (!empty($entity->feeds_item->skip)) {
+          continue;
+        }
+
+        // This will throw an exception on failure.
+        $this->entitySaveAccess($entity);
+        $this->entitySave($entity);
+
+        // Allow modules to perform operations using the saved entity data.
+        // $entity contains the updated entity after saving.
+        module_invoke_all('feeds_after_save', $source, $entity, $item, $entity_id);
+
+        // Track progress.
+        if (empty($entity_id)) {
+          $state->created++;
+        }
+        else {
+          $state->updated++;
+        }
+      }
+
+      // Something bad happened, log it.
+      catch (Exception $e) {
+        $state->failed++;
+        drupal_set_message($e->getMessage(), 'warning');
+        $message = $this->createLogMessage($e, $entity, $item);
+        $source->log('import', $message, array(), WATCHDOG_ERROR);
+      }
+    }
+
+    // Set messages if we're done.
+    if ($source->progressImporting() != FEEDS_BATCH_COMPLETE) {
+      return;
+    }
+    // Remove not included items if needed.
+    // It depends on the implementation of the clean() method what will happen
+    // to items that were no longer in the source.
+    $this->clean($state);
+    $info = $this->entityInfo();
+    $tokens = array(
+      '@entity' => strtolower($info['label']),
+      '@entities' => strtolower($info['label plural']),
+    );
+    $messages = array();
+    if ($state->created) {
+      $messages[] = array(
+       'message' => format_plural(
+          $state->created,
+          'Created @number @entity.',
+          'Created @number @entities.',
+          array('@number' => $state->created) + $tokens
+        ),
+      );
+    }
+    if ($state->updated) {
+      $messages[] = array(
+       'message' => format_plural(
+          $state->updated,
+          'Updated @number @entity.',
+          'Updated @number @entities.',
+          array('@number' => $state->updated) + $tokens
+        ),
+      );
+    }
+    if ($state->unpublished) {
+      $messages[] = array(
+        'message' => format_plural(
+            $state->unpublished,
+            'Unpublished @number @entity.',
+            'Unpublished @number @entities.',
+            array('@number' => $state->unpublished) + $tokens
+        ),
+      );
+    }
+    if ($state->deleted) {
+      $messages[] = array(
+       'message' => format_plural(
+          $state->deleted,
+          'Removed @number @entity.',
+          'Removed @number @entities.',
+          array('@number' => $state->deleted) + $tokens
+        ),
+      );
+    }
+    if ($state->failed) {
+      $messages[] = array(
+       'message' => format_plural(
+          $state->failed,
+          'Failed importing @number @entity.',
+          'Failed importing @number @entities.',
+          array('@number' => $state->failed) + $tokens
+        ),
+        'level' => WATCHDOG_ERROR,
+      );
+    }
+    if (empty($messages)) {
+      $messages[] = array(
+        'message' => t('There are no new @entities.', array('@entities' => strtolower($info['label plural']))),
+      );
+    }
+    foreach ($messages as $message) {
+      drupal_set_message($message['message']);
+      $source->log('import', $message['message'], array(), isset($message['level']) ? $message['level'] : WATCHDOG_INFO);
+    }
+  }
+
+  /**
+   * Initialize the array of entities to remove with all existing entities
+   * previously imported from the source.
+   *
+   * @param FeedsSource $source
+   *   Source information about this import.
+   * @param FeedsState $state
+   *   The FeedsState object for the given stage.
+   */
+  protected function initEntitiesToBeRemoved(FeedsSource $source, FeedsState $state) {
+    $state->removeList = array();
+    // We fill it only if needed.
+    if (!isset($this->config['update_non_existent']) || $this->config['update_non_existent'] == FEEDS_SKIP_NON_EXISTENT) {
+      return;
+    }
+    // Build base select statement.
+    $info = $this->entityInfo();
+    $id_key = db_escape_field($info['entity keys']['id']);
+    $select = db_select($info['base table'], 'e');
+    $select->addField('e', $info['entity keys']['id'], 'entity_id');
+    $select->join(
+      'feeds_item',
+      'fi',
+      'e.' . $id_key . ' = fi.entity_id AND fi.entity_type = :entity_type', array(
+        ':entity_type' => $this->entityType(),
+    ));
+
+    $select->condition('fi.id', $this->id);
+    $select->condition('fi.feed_nid', $source->feed_nid);
+    $entities = $select->execute();
+    // If not found on process, existing entities will be deleted.
+    foreach ($entities as $entity) {
+      // Obviously, items which are still included in the source feed will be
+      // removed from this array when processed.
+      $state->removeList[$entity->entity_id] = $entity->entity_id;
+    }
+  }
+
+  /**
+   * Deletes entities which were not found during processing.
+   *
+   * @todo batch delete?
+   *
+   * @param FeedsState $state
+   *   The FeedsState object for the given stage.
+   */
+  protected function clean(FeedsState $state) {
+    // We clean only if needed.
+    if (!isset($this->config['update_non_existent']) || $this->config['update_non_existent'] == FEEDS_SKIP_NON_EXISTENT) {
+      return;
+    }
+
+    $total = count($state->removeList);
+    if ($total) {
+      $this->entityDeleteMultiple($state->removeList);
+      $state->deleted += $total;
+    }
+  }
+
+  /**
+   * Remove all stored results or stored results up to a certain time for a
+   * source.
+   *
+   * @param FeedsSource $source
+   *   Source information for this expiry. Implementers should only delete items
+   *   pertaining to this source. The preferred way of determining whether an
+   *   item pertains to a certain souce is by using $source->feed_nid. It is the
+   *   processor's responsibility to store the feed_nid of an imported item in
+   *   the processing stage.
+   */
+  public function clear(FeedsSource $source) {
+    $state = $source->state(FEEDS_PROCESS_CLEAR);
+
+    // Build base select statement.
+    $info = $this->entityInfo();
+    $select = db_select($info['base table'], 'e');
+    $select->addField('e', $info['entity keys']['id'], 'entity_id');
+    $select->join(
+      'feeds_item',
+      'fi',
+      "e.{$info['entity keys']['id']} = fi.entity_id AND fi.entity_type = '{$this->entityType()}'");
+    $select->condition('fi.id', $this->id);
+    $select->condition('fi.feed_nid', $source->feed_nid);
+
+    // If there is no total, query it.
+    if (!$state->total) {
+      $state->total = $select->countQuery()
+        ->execute()
+        ->fetchField();
+    }
+
+    // Delete a batch of entities.
+    $entities = $select->range(0, $this->getLimit())->execute();
+    $entity_ids = array();
+    foreach ($entities as $entity) {
+      $entity_ids[$entity->entity_id] = $entity->entity_id;
+    }
+    $this->entityDeleteMultiple($entity_ids);
+
+    // Report progress, take into account that we may not have deleted as
+    // many items as we have counted at first.
+    if (count($entity_ids)) {
+      $state->deleted += count($entity_ids);
+      $state->progress($state->total, $state->deleted);
+    }
+    else {
+      $state->progress($state->total, $state->total);
+    }
+
+    // Report results when done.
+    if ($source->progressClearing() == FEEDS_BATCH_COMPLETE) {
+      if ($state->deleted) {
+        $message = format_plural(
+          $state->deleted,
+          'Deleted @number @entity',
+          'Deleted @number @entities',
+          array(
+            '@number' => $state->deleted,
+            '@entity' => strtolower($info['label']),
+            '@entities' => strtolower($info['label plural']),
+          )
+        );
+        $source->log('clear', $message, array(), WATCHDOG_INFO);
+        drupal_set_message($message);
+      }
+      else {
+        drupal_set_message(t('There are no @entities to be deleted.', array('@entities' => $info['label plural'])));
+      }
+    }
+  }
+
+  /*
+   * Report number of items that can be processed per call.
+   *
+   * 0 means 'unlimited'.
+   *
+   * If a number other than 0 is given, Feeds parsers that support batching
+   * will only deliver this limit to the processor.
+   *
+   * @see FeedsSource::getLimit()
+   * @see FeedsCSVParser::parse()
+   */
+  public function getLimit() {
+    return variable_get('feeds_process_limit', FEEDS_PROCESS_LIMIT);
+  }
+
+  /**
+   * Deletes feed items older than REQUEST_TIME - $time.
+   *
+   * Do not invoke expire on a processor directly, but use
+   * FeedsSource::expire() instead.
+   *
+   * @param FeedsSource $source
+   *   The source to expire entities for.
+   *
+   * @param $time
+   *   (optional) All items produced by this configuration that are older than
+   *   REQUEST_TIME - $time should be deleted. If NULL, processor should use
+   *   internal configuration. Defaults to NULL.
+   *
+   * @return float
+   *   FEEDS_BATCH_COMPLETE if all items have been processed, a float between 0
+   *   and 0.99* indicating progress otherwise.
+   *
+   * @see FeedsSource::expire()
+   */
+  public function expire(FeedsSource $source, $time = NULL) {
+    $state = $source->state(FEEDS_PROCESS_EXPIRE);
+
+    if ($time === NULL) {
+      $time = $this->expiryTime();
+    }
+    if ($time == FEEDS_EXPIRE_NEVER) {
+      return;
+    }
+
+    $select = $this->expiryQuery($source, $time);
+
+    // If there is no total, query it.
+    if (!$state->total) {
+      $state->total = $select->countQuery()->execute()->fetchField();
+    }
+
+    // Delete a batch of entities.
+    $entity_ids = $select->range(0, $this->getLimit())->execute()->fetchCol();
+    if ($entity_ids) {
+      $this->entityDeleteMultiple($entity_ids);
+      $state->deleted += count($entity_ids);
+      $state->progress($state->total, $state->deleted);
+    }
+    else {
+      $state->progress($state->total, $state->total);
+    }
+  }
+
+  /**
+   * Returns a database query used to select entities to expire.
+   *
+   * Processor classes should override this method to set the age portion of the
+   * query.
+   *
+   * @param FeedsSource $source
+   *   The feed source.
+   * @param int $time
+   *   Delete entities older than this.
+   *
+   * @return SelectQuery
+   *   A select query to execute.
+   *
+   * @see FeedsNodeProcessor::expiryQuery()
+   */
+  protected function expiryQuery(FeedsSource $source, $time) {
+    // Build base select statement.
+    $info = $this->entityInfo();
+    $id_key = db_escape_field($info['entity keys']['id']);
+
+    $select = db_select($info['base table'], 'e');
+    $select->addField('e', $info['entity keys']['id'], 'entity_id');
+    $select->join(
+      'feeds_item',
+      'fi',
+      "e.$id_key = fi.entity_id AND fi.entity_type = :entity_type", array(
+        ':entity_type' => $this->entityType(),
+    ));
+    $select->condition('fi.id', $this->id);
+    $select->condition('fi.feed_nid', $source->feed_nid);
+
+    return $select;
+  }
+
+  /**
+   * Counts the number of items imported by this processor.
+   */
+  public function itemCount(FeedsSource $source) {
+    return db_query("SELECT count(*) FROM {feeds_item} WHERE id = :id AND entity_type = :entity_type AND feed_nid = :feed_nid", array(':id' => $this->id, ':entity_type' => $this->entityType(), ':feed_nid' => $source->feed_nid))->fetchField();
+  }
+
+  /**
+   * Execute mapping on an item.
+   *
+   * This method encapsulates the central mapping functionality. When an item is
+   * processed, it is passed through map() where the properties of $source_item
+   * are mapped onto $target_item following the processor's mapping
+   * configuration.
+   *
+   * For each mapping FeedsParser::getSourceElement() is executed to retrieve
+   * the source element, then FeedsProcessor::setTargetElement() is invoked
+   * to populate the target item properly. Alternatively a
+   * hook_x_targets_alter() may have specified a callback for a mapping target
+   * in which case the callback is asked to populate the target item instead of
+   * FeedsProcessor::setTargetElement().
+   *
+   * @ingroup mappingapi
+   *
+   * @see hook_feeds_parser_sources_alter()
+   * @see hook_feeds_data_processor_targets_alter()
+   * @see hook_feeds_node_processor_targets_alter()
+   * @see hook_feeds_term_processor_targets_alter()
+   * @see hook_feeds_user_processor_targets_alter()
+   */
+  protected function map(FeedsSource $source, FeedsParserResult $result, $target_item = NULL) {
+
+    // Static cache $targets as getMappingTargets() may be an expensive method.
+    static $sources;
+    if (!isset($sources[$this->id])) {
+      $sources[$this->id] = feeds_importer($this->id)->parser->getMappingSources();
+    }
+    static $targets;
+    if (!isset($targets[$this->id])) {
+      $targets[$this->id] = $this->getMappingTargets();
+    }
+    $parser = feeds_importer($this->id)->parser;
+    if (empty($target_item)) {
+      $target_item = array();
+    }
+
+    // Many mappers add to existing fields rather than replacing them. Hence we
+    // need to clear target elements of each item before mapping in case we are
+    // mapping on a prepopulated item such as an existing node.
+    foreach ($this->config['mappings'] as $mapping) {
+      if (isset($targets[$this->id][$mapping['target']]['real_target'])) {
+        $target_item->{$targets[$this->id][$mapping['target']]['real_target']} = NULL;
+      }
+      else {
+        $target_item->{$mapping['target']} = NULL;
+      }
+    }
+
+    /*
+    This is where the actual mapping happens: For every mapping we envoke
+    the parser's getSourceElement() method to retrieve the value of the source
+    element and pass it to the processor's setTargetElement() to stick it
+    on the right place of the target item.
+
+    If the mapping specifies a callback method, use the callback instead of
+    setTargetElement().
+    */
+    self::loadMappers();
+    foreach ($this->config['mappings'] as $mapping) {
+      // Retrieve source element's value from parser.
+      if (isset($sources[$this->id][$mapping['source']]) &&
+          is_array($sources[$this->id][$mapping['source']]) &&
+          isset($sources[$this->id][$mapping['source']]['callback']) &&
+          function_exists($sources[$this->id][$mapping['source']]['callback'])) {
+        $callback = $sources[$this->id][$mapping['source']]['callback'];
+        $value = $callback($source, $result, $mapping['source']);
+      }
+      else {
+        $value = $parser->getSourceElement($source, $result, $mapping['source']);
+      }
+
+      // Map the source element's value to the target.
+      if (isset($targets[$this->id][$mapping['target']]) &&
+          is_array($targets[$this->id][$mapping['target']]) &&
+          isset($targets[$this->id][$mapping['target']]['callback']) &&
+          function_exists($targets[$this->id][$mapping['target']]['callback'])) {
+        $callback = $targets[$this->id][$mapping['target']]['callback'];
+
+        // All target callbacks expect an array.
+        if (!is_array($value)) {
+          $value = array($value);
+        }
+
+        $callback($source, $target_item, $mapping['target'], $value, $mapping);
+      }
+      else {
+        $this->setTargetElement($source, $target_item, $mapping['target'], $value, $mapping);
+      }
+    }
+
+    return $target_item;
+  }
+
+  /**
+   * Per default, don't support expiry. If processor supports expiry of imported
+   * items, return the time after which items should be removed.
+   */
+  public function expiryTime() {
+    return FEEDS_EXPIRE_NEVER;
+  }
+
+  /**
+   * Declare default configuration.
+   */
+  public function configDefaults() {
+    $info = $this->entityInfo();
+    $bundle = NULL;
+    if (empty($info['entity keys']['bundle'])) {
+      $bundle = $this->entityType();
+    }
+    return array(
+      'mappings' => array(),
+      'update_existing' => FEEDS_SKIP_EXISTING,
+      'update_non_existent' => FEEDS_SKIP_NON_EXISTENT,
+      'input_format' => NULL,
+      'skip_hash_check' => FALSE,
+      'bundle' => $bundle,
+    );
+  }
+
+  /**
+   * Overrides parent::configForm().
+   */
+  public function configForm(&$form_state) {
+    $info = $this->entityInfo();
+    $form = array();
+
+    if (!empty($info['entity keys']['bundle'])) {
+      $form['bundle'] = array(
+        '#type' => 'select',
+        '#options' => $this->bundleOptions(),
+        '#title' => !empty($info['bundle name']) ? $info['bundle name'] : t('Bundle'),
+        '#required' => TRUE,
+        '#default_value' => $this->bundle(),
+      );
+    }
+    else {
+      $form['bundle'] = array(
+        '#type' => 'value',
+        '#value' => $this->entityType(),
+      );
+    }
+
+    $tokens = array('@entities' => strtolower($info['label plural']));
+
+    $form['update_existing'] = array(
+      '#type' => 'radios',
+      '#title' => t('Update existing @entities', $tokens),
+      '#description' =>
+        t('Existing @entities will be determined using mappings that are a "unique target".', $tokens),
+      '#options' => array(
+        FEEDS_SKIP_EXISTING => t('Do not update existing @entities', $tokens),
+        FEEDS_REPLACE_EXISTING => t('Replace existing @entities', $tokens),
+        FEEDS_UPDATE_EXISTING => t('Update existing @entities', $tokens),
+      ),
+      '#default_value' => $this->config['update_existing'],
+    );
+    global $user;
+    $formats = filter_formats($user);
+    foreach ($formats as $format) {
+      $format_options[$format->format] = $format->name;
+    }
+    $form['skip_hash_check'] = array(
+      '#type' => 'checkbox',
+      '#title' => t('Skip hash check'),
+      '#description' => t('Force update of items even if item source data did not change.'),
+      '#default_value' => $this->config['skip_hash_check'],
+    );
+    $form['input_format'] = array(
+      '#type' => 'select',
+      '#title' => t('Text format'),
+      '#description' => t('Select the default input format for the text fields of the nodes to be created.'),
+      '#options' => $format_options,
+      '#default_value' => isset($this->config['input_format']) ? $this->config['input_format'] : 'plain_text',
+      '#required' => TRUE,
+    );
+
+    $form['update_non_existent'] = array(
+      '#type' => 'radios',
+      '#title' => t('Action to take when previously imported @entities are missing in the feed', $tokens),
+      '#description' => t('Select how @entities previously imported and now missing in the feed should be updated.', $tokens),
+      '#options' => array(
+        FEEDS_SKIP_NON_EXISTENT => t('Skip non-existent @entities', $tokens),
+        FEEDS_DELETE_NON_EXISTENT => t('Delete non-existent @entities', $tokens),
+      ),
+      '#default_value' => $this->config['update_non_existent'],
+    );
+
+    return $form;
+  }
+
+  /**
+   * Get mappings.
+   */
+  public function getMappings() {
+    return isset($this->config['mappings']) ? $this->config['mappings'] : array();
+  }
+
+  /**
+   * Declare possible mapping targets that this processor exposes.
+   *
+   * @ingroup mappingapi
+   *
+   * @return
+   *   An array of mapping targets. Keys are paths to targets
+   *   separated by ->, values are TRUE if target can be unique,
+   *   FALSE otherwise.
+   */
+  public function getMappingTargets() {
+
+    // The bundle has not been selected.
+    if (!$this->bundle()) {
+      $info = $this->entityInfo();
+      $bundle_name = !empty($info['bundle name']) ? drupal_strtolower($info['bundle name']) : t('bundle');
+      $plugin_key = feeds_importer($this->id)->config['processor']['plugin_key'];
+      $url = url('admin/structure/feeds/' . $this->id . '/settings/' . $plugin_key);
+      drupal_set_message(t('Please <a href="@url">select a @bundle_name</a>.', array('@url' => $url, '@bundle_name' => $bundle_name)), 'warning', FALSE);
+    }
+
+    return array(
+      'url' => array(
+        'name' => t('URL'),
+        'description' => t('The external URL of the item. E. g. the feed item URL in the case of a syndication feed. May be unique.'),
+        'optional_unique' => TRUE,
+      ),
+      'guid' => array(
+        'name' => t('GUID'),
+        'description' => t('The globally unique identifier of the item. E. g. the feed item GUID in the case of a syndication feed. May be unique.'),
+        'optional_unique' => TRUE,
+      ),
+    );
+  }
+
+  /**
+   * Set a concrete target element. Invoked from FeedsProcessor::map().
+   *
+   * @ingroup mappingapi
+   */
+  public function setTargetElement(FeedsSource $source, $target_item, $target_element, $value) {
+    switch ($target_element) {
+      case 'url':
+      case 'guid':
+        $target_item->feeds_item->$target_element = $value;
+        break;
+      default:
+        $target_item->$target_element = $value;
+        break;
+    }
+  }
+
+  /**
+   * Retrieve the target entity's existing id if available. Otherwise return 0.
+   *
+   * @ingroup mappingapi
+   *
+   * @param FeedsSource $source
+   *   The source information about this import.
+   * @param FeedsParserResult $result
+   *   A FeedsParserResult object.
+   *
+   * @return int
+   *   The serial id of an entity if found, 0 otherwise.
+   */
+  protected function existingEntityId(FeedsSource $source, FeedsParserResult $result) {
+    $targets = &drupal_static('FeedsProcessor::existingEntityId', array());
+    if (!isset($targets[$this->id])) {
+      $targets[$this->id] = $this->getMappingTargets();
+    }
+
+    $entity_id = 0;
+
+    // Iterate through all unique targets and test whether they already exist in
+    // the database.
+    foreach ($this->uniqueTargets($source, $result) as $target => $value) {
+      if ($target === 'guid' || $target === 'url') {
+        $entity_id = db_select('feeds_item')
+          ->fields('feeds_item', array('entity_id'))
+          ->condition('feed_nid', $source->feed_nid)
+          ->condition('entity_type', $this->entityType())
+          ->condition('id', $source->id)
+          ->condition($target, $value)
+          ->execute()
+          ->fetchField();
+      }
+
+      if (!$entity_id && !empty($targets[$this->id][$target]['unique_callbacks'])) {
+        if (!is_array($value)) {
+          $value = array($value);
+        }
+
+        foreach ($targets[$this->id][$target]['unique_callbacks'] as $callback) {
+          if (is_callable($callback) && $entity_id = call_user_func_array($callback, array($source, $this->entityType(), $this->bundle(), $target, $value))) {
+            // Stop at the first unique ID returned by a callback.
+            break;
+          }
+        }
+      }
+
+      // Return with the content id found.
+      if ($entity_id) {
+        return $entity_id;
+      }
+    }
+
+    return $entity_id;
+  }
+
+
+  /**
+   * Utility function that iterates over a target array and retrieves all
+   * sources that are unique.
+   *
+   * @param $batch
+   *   A FeedsImportBatch.
+   *
+   * @return
+   *   An array where the keys are target field names and the values are the
+   *   elements from the source item mapped to these targets.
+   */
+  protected function uniqueTargets(FeedsSource $source, FeedsParserResult $result) {
+    $parser = feeds_importer($this->id)->parser;
+    $targets = array();
+    foreach ($this->config['mappings'] as $mapping) {
+      if (!empty($mapping['unique'])) {
+        // Invoke the parser's getSourceElement to retrieve the value for this
+        // mapping's source.
+        $targets[$mapping['target']] = $parser->getSourceElement($source, $result, $mapping['source']);
+      }
+    }
+    return $targets;
+  }
+
+  /**
+   * Adds Feeds specific information on $entity->feeds_item.
+   *
+   * @param $entity
+   *   The entity object to be populated with new item info.
+   * @param $feed_nid
+   *   The feed nid of the source that produces this entity.
+   * @param $hash
+   *   The fingerprint of the source item.
+   */
+  protected function newItemInfo($entity, $feed_nid, $hash = '') {
+    $entity->feeds_item = new stdClass();
+    $entity->feeds_item->is_new = TRUE;
+    $entity->feeds_item->entity_id = 0;
+    $entity->feeds_item->entity_type = $this->entityType();
+    $entity->feeds_item->id = $this->id;
+    $entity->feeds_item->feed_nid = $feed_nid;
+    $entity->feeds_item->imported = REQUEST_TIME;
+    $entity->feeds_item->hash = $hash;
+    $entity->feeds_item->url = '';
+    $entity->feeds_item->guid = '';
+  }
+
+  /**
+   * Loads existing entity information and places it on $entity->feeds_item.
+   *
+   * @param $entity
+   *   The entity object to load item info for. Id key must be present.
+   *
+   * @return
+   *   TRUE if item info could be loaded, false if not.
+   */
+  protected function loadItemInfo($entity) {
+    $entity_info = entity_get_info($this->entityType());
+    $key = $entity_info['entity keys']['id'];
+    if ($item_info = feeds_item_info_load($this->entityType(), $entity->$key)) {
+      $entity->feeds_item = $item_info;
+      return TRUE;
+    }
+    return FALSE;
+  }
+
+  /**
+   * Create MD5 hash of item and mappings array.
+   *
+   * Include mappings as a change in mappings may have an affect on the item
+   * produced.
+   *
+   * @return Always returns a hash, even with empty, NULL, FALSE:
+   *  Empty arrays return 40cd750bba9870f18aada2478b24840a
+   *  Empty/NULL/FALSE strings return d41d8cd98f00b204e9800998ecf8427e
+   */
+  protected function hash($item) {
+    return hash('md5', serialize($item) . serialize($this->config['mappings']));
+  }
+
+  /**
+   * Retrieves the MD5 hash of $entity_id from the database.
+   *
+   * @return string
+   *   Empty string if no item is found, hash otherwise.
+   */
+  protected function getHash($entity_id) {
+
+    if ($hash = db_query("SELECT hash FROM {feeds_item} WHERE entity_type = :type AND entity_id = :id", array(':type' => $this->entityType(), ':id' => $entity_id))->fetchField()) {
+      // Return with the hash.
+      return $hash;
+    }
+    return '';
+  }
+
+  /**
+   * Creates a log message for when an exception occured during import.
+   *
+   * @param Exception $e
+   *   The exception that was throwned during processing the item.
+   * @param $entity
+   *   The entity object.
+   * @param $item
+   *   The parser result for this entity.
+   *
+   * @return string
+   *   The message to log.
+   */
+  protected function createLogMessage(Exception $e, $entity, $item) {
+    include_once DRUPAL_ROOT . '/includes/utility.inc';
+    $message = $e->getMessage();
+    $message .= '<h3>Original item</h3>';
+    $message .= '<pre>' . drupal_var_export($item). '</pre>';
+    $message .= '<h3>Entity</h3>';
+    $message .= '<pre>' . drupal_var_export($entity) . '</pre>';
+    return $message;
+  }
+
+  /**
+   * Overrides FeedsPlugin::dependencies().
+   */
+  public function dependencies() {
+    $dependencies = parent::dependencies();
+
+    // Find out which module defined the entity type.
+    $info = $this->entityInfo();
+    if (isset($info['module'])) {
+      $dependencies[$info['module']] = $info['module'];
+    }
+
+    return $dependencies;
+  }
+
+}
+
+class FeedsProcessorBundleNotDefined extends Exception {}
diff --git a/tests/feeds/multilingual.csv b/tests/feeds/multilingual.csv
new file mode 100644
index 0000000..902dec7
--- /dev/null
+++ b/tests/feeds/multilingual.csv
@@ -0,0 +1,2 @@
+"guid","title","title_fr","body","body_fr","link","link_fr","number","number_fr","image","image_fr","category","category_fr"
+1,"Testing Multilingual Feeds 1","Teste Feeds Multilingue 1","This is the body","Ceci est la corps","http://google.ca","http://google.fr",1000,2000,"public://images/foosball.jpeg","public://images/la fayette.jpeg","News","Nouvelles"
diff --git a/tests/feeds_mapper_multilingual_fields.test b/tests/feeds_mapper_multilingual_fields.test
new file mode 100644
index 0000000..61cd016
--- /dev/null
+++ b/tests/feeds_mapper_multilingual_fields.test
@@ -0,0 +1,261 @@
+<?php
+
+/**
+ * @file
+ * Test case for multilingual feeds
+ */
+
+/**
+ * Class for testing Feeds <em>content</em> mapper (with field translation
+ * provided by the entity_translation module)
+ */
+class FeedsMapperMultilingualFieldsTestCase extends FeedsMapperTestCase {
+  public static function getInfo() {
+    return array(
+      'name' => 'Mapper: Multilingual Fields',
+      'description' => 'Test Feeds Multilingual support.',
+      'group' => 'Feeds',
+      'dependencies' => array('entity_translation'),
+    );
+  }
+
+  function setUp() {
+
+    // Modules
+    $modules = array(
+      'locale',
+      'entity_translation',
+      'link',
+      'number',
+    );
+
+    $permissions = array(
+      'administer entity translation',
+      'translate any entity',
+      'administer languages',
+    );
+
+    parent::setUp($modules, $permissions);
+
+    // Add Categories vocabulary
+    $edit = array(
+      'name' => 'Categories',
+      'machine_name' => 'categories',
+    );
+    $this->drupalPost('admin/structure/taxonomy/add', $edit, 'Save');
+
+    // Create content type.
+    $typename = $this->createContentType(array(),
+      array(
+        'number' => 'number_integer',
+        'link' => 'link_field',
+        'image' => 'image',
+      )
+    );
+
+    // Create term reference field.
+    $field = array(
+      'field_name' => 'field_category',
+      'type' => 'taxonomy_term_reference',
+      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
+      'settings' => array(
+        'allowed_values' => array(
+          array(
+            'vocabulary' => 'categories',
+            'parent' => 0,
+          ),
+        ),
+      ),
+    );
+    field_create_field($field);
+
+    // Add term reference field to article bundle.
+    $this->instance = array(
+      'field_name' => 'field_category',
+      'bundle' => $typename,
+      'entity_type' => 'node',
+      'widget' => array(
+        'type' => 'options_select',
+      ),
+      'display' => array(
+        'default' => array(
+          'type' => 'taxonomy_term_reference_link',
+        ),
+      ),
+    );
+    field_create_instance($this->instance);
+
+    // Configure Multilingual
+    $this->setupMultilingual($typename);
+
+    // Copy directory of source files, CSV file expects them in public://images
+    $this->copyDir($this->absolutePath() . '/tests/feeds/assets', 'public://images');
+
+    // Create an importer configuration with basic mapping.
+    $this->createImporterConfiguration('Test Multilingual Fields import from CSV', 'node');
+    $this->setPlugin('node', 'FeedsCSVParser');
+    $this->setPlugin('node', 'FeedsFileFetcher');
+    $this->setSettings('node', NULL, array('content_type' => ''));
+    $this->setSettings('node', 'FeedsNodeProcessor', array('bundle' => $typename, 'language' => 'en'));
+    $this->addMappings('node',
+      array(
+        array(
+          'source' => 'guid',
+          'target' => 'guid',
+          'unique' => TRUE,
+        ),
+        array(
+          'source' => 'title',
+          'target' => 'title',
+        ),
+        array(
+          'source' => 'body',
+          'target' => 'body',
+          'language' => 'en',
+        ),
+        array(
+          'source' => 'body_fr',
+          'target' => 'body',
+          'language' => 'fr',
+        ),
+        array(
+          'source' => 'number',
+          'target' => 'field_number',
+          'language' => 'en',
+        ),
+        array(
+          'source' => 'number_fr',
+          'target' => 'field_number',
+          'language' => 'fr',
+        ),
+        array(
+          'source' => 'link',
+          'target' => 'field_link:url',
+          'language' => 'en',
+        ),
+        array(
+          'source' => 'link_fr',
+          'target' => 'field_link:url',
+          'language' => 'fr',
+        ),
+        array(
+          'source' => 'image',
+          'target' => 'field_image:uri',
+          'language' => 'en',
+        ),
+        array(
+          'source' => 'image_fr',
+          'target' => 'field_image:uri',
+          'language' => 'fr',
+        ),
+        array(
+          'source' => 'category',
+          'target' => 'field_category',
+          'language' => 'en',
+          'autocreate' => TRUE,
+        ),
+        array(
+          'source' => 'category_fr',
+          'target' => 'field_category',
+          'language' => 'fr',
+          'autocreate' => TRUE,
+        ),
+      )
+    );
+  }
+
+  /**
+   * Tests multilingual mappings to translatable fields (entity translation)
+   */
+  public function testMultilingualFieldMappings() {
+
+    // Run Import
+    // Import CSV file.
+    $this->importFile('node', $this->absolutePath() . '/tests/feeds/multilingual.csv');
+    $this->assertText('Created 1 node');
+
+    // Check english field values
+    $this->drupalGet('en/node/1/edit');
+    $this->assertFieldByName("body[en][0][value]", 'This is the body', t('Found english form field for <em>body</em> with the expected value.'));
+    $this->assertFieldByName("field_number[en][0][value]", 1000, t('Found english form field for <em>number</em> with the expected value.'));
+    $this->assertFieldByName("field_link[en][0][url]", 'http://google.ca', t('Found english form field for <em>link</em> with the expected value.'));
+    $this->assertText("foosball.jpeg", t('Found english form field for <em>image</em> with the expected value.'));
+    $this->assertOptionSelected('edit-field-category-en', 1, t('Found english form field for <em>category</em> with the expected value'));
+
+    //
+    // Check French Field Values
+    $this->drupalGet('fr/node/1/edit');
+    $this->assertFieldByName("body[fr][0][value]", 'Ceci est la corps', t('Found french form field for <em>body</em> with the expected value.'));
+    $this->assertFieldByName("field_number[fr][0][value]", 2000, t('Found french form field for <em>number</em> with the expected value.'));
+    $this->assertFieldByName("field_link[fr][0][url]", 'http://google.fr', t('Found french form field for <em>link</em> with the expected value.'));
+    $this->assertText("la fayette.jpeg", t('Found french form field for <em>image</em> with the expected value.'));
+    $this->assertOptionSelected('edit-field-category-fr', 2, t('Found french form field for <em>category</em> with the expected value'));
+
+  }
+
+  /**
+   * Configures Drupal to be multilingual
+   */
+  public function setupMultilingual($typename) {
+    // Setup Other Language (french)
+    $edit = array(
+      'langcode' => 'fr',
+    );
+    $this->drupalPost('admin/config/regional/language/add', $edit, 'Add language');
+    $this->assertText('The language French has been created and can now be used.');
+
+    // Configure English Path Prefix
+    $edit = array(
+      'prefix' => 'en',
+    );
+    $this->drupalPost('admin/config/regional/language/edit/en', $edit, 'Save language');
+    // Configure French Path Prefix
+    $edit = array(
+      'prefix' => 'fr',
+    );
+    $this->drupalPost('admin/config/regional/language/edit/fr', $edit, 'Save language');
+
+    // Configure Language Detection
+    $edit = array(
+      'language[enabled][locale-url]' =>  1,
+      'language[weight][locale-url]' =>  -10,
+      'language[weight][locale-browser]' =>  -9,
+      'language[weight][locale-session]' =>  -8,
+      'language[weight][locale-user]' =>  -7,
+      'language[weight][language-default]' =>  -6,
+      'language_content[enabled][locale-url]' =>  1,
+      'language_content[weight][locale-url]' =>  -10,
+      'language_content[weight][locale-browser]' =>  -9,
+      'language_content[weight][locale-session]' =>  -8,
+      'language_content[weight][locale-user]' =>  -7,
+      'language_content[enabled][locale-interface]' =>  1,
+      'language_content[weight][locale-interface]' =>  -6,
+      'language_content[weight][language-default]' =>  -5,
+    );
+    $this->drupalPost('admin/config/regional/language/configure', $edit, 'Save settings');
+
+    // Enable entity field translation for content type
+    $edit = array(
+      'language_content_type' => 4,
+      'entity_translation_hide_translation_links' => 1,
+      'entity_translation_node_metadata' => 0,
+    );
+    $this->drupalPost('admin/structure/types/manage/' . $typename, $edit, t('Save content type'));
+
+    // Enable field translation on fields
+    $edit = array(
+      'field[translatable]' => 1,
+    );
+    $field_names = array(
+      'body' => 'body',
+      'field_number' => 'field_number',
+      'field_link' => 'field_link',
+      'field_image' => 'field_image',
+      'field_category' => 'field_category',
+    );
+    foreach ($field_names as $field_name) {
+      $this->drupalPost("admin/structure/types/manage/{$typename}/fields/{$field_name}", $edit, t('Save settings'));
+    }
+  }
+
+}
diff --git a/tests/feeds_tests.info b/tests/feeds_tests.info
index 0e1d123..f135070 100644
--- a/tests/feeds_tests.info
+++ b/tests/feeds_tests.info
@@ -4,4 +4,5 @@ package = Testing
 version = VERSION
 core = 7.x
 test_dependencies[] = entity
+test_dependencies[] = entity_translation
 hidden = TRUE
